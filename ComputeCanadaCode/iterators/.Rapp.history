basinsfinalboth[(1+((i-1)*100)+1):(((i)*99)+1),]
basinsfinalboth[(1+((i-1)*100)+1):(((i)*100)+1),]
basinsfinalboth[(1+((i-1)*100)+1):(((i)*99)+1),]
basinsfinal[(((i-1)*99)+1):((i)*99),]
basinsfinalboth[(1+((i-1)*100)+1):(1+((i-1)*100)+100),]
basinsfinalboth[(1+((i-1)*100)+1):(1+((i-1)*100)+99),]
i <- 1
basinsfinalboth[(1+((i-1)*100)+1):(1+((i-1)*100)+99),]
i <- 3
basinsfinalboth[(1+((i-1)*100)+1):(1+((i-1)*100)+99),]
basinsfinalboth[(1+((i-1)*100)),]
basinsfinalzero_all[i,]
basinsfinal[(((i-1)*99)+1):((i)*99),]
i <- 495
basinsfinalzero_all[i,]
basinsfinal[(((i-1)*99)+1):((i)*99),]
i <- 496
basinsfinal[(((i-1)*99)+1):((i)*99),]
dim(basinsfinalzero_all)[1]
for(i in 1:(dim(basinsfinalzero_all)[1])){#
basinsfinalboth[(1+((i-1)*100)),] <- basinsfinalzero_all[i,]	#
basinsfinalboth[(1+((i-1)*100)+1):(1+((i-1)*100)+99),] <- basinsfinal[(((i-1)*99)+1):((i)*99),]#
}
basinsfinalabr <- basinsfinalboth[basinsfinalboth[,3] <= 0.45,]
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "5%",zlim=c(0,100), ylim = c(0,0.45))
par(mfrow = c(3,5))#
#
#double high coral#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))#
#
#double high macroalgae#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#mixed mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,8] + basinsfinalabr[basinsfinalabr[,1] == 0.05,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,8] + basinsfinalabr[basinsfinalabr[,1] == 0.10,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,8] + basinsfinalabr[basinsfinalabr[,1] == 0.25,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,8] + basinsfinalabr[basinsfinalabr[,1] == 0.50,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,8]+basinsfinalabr[basinsfinalabr[,1] == 1,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))
par(mfrow = c(4,5))#
#
#double high coral#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))#
#
#double high macroalgae#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#pure mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,6] + basinsfinalabr[basinsfinalabr[,1] == 0.05,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,6] + basinsfinalabr[basinsfinalabr[,1] == 0.10,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,6] + basinsfinalabr[basinsfinalabr[,1] == 0.25,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,6] + basinsfinalabr[basinsfinalabr[,1] == 0.50,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,6]+basinsfinalabr[basinsfinalabr[,1] == 1,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#mixed mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,8] + basinsfinalabr[basinsfinalabr[,1] == 0.05,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,8] + basinsfinalabr[basinsfinalabr[,1] == 0.10,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,8] + basinsfinalabr[basinsfinalabr[,1] == 0.25,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,8] + basinsfinalabr[basinsfinalabr[,1] == 0.50,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,8]+basinsfinalabr[basinsfinalabr[,1] == 1,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))
par(mfrow = c(4,5))#
#
#double high coral#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))#
#
#double high macroalgae#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighM1M2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#pure mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,6] + basinsfinalabr[basinsfinalabr[,1] == 0.05,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "Pure mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,6] + basinsfinalabr[basinsfinalabr[,1] == 0.10,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,6] + basinsfinalabr[basinsfinalabr[,1] == 0.25,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,6] + basinsfinalabr[basinsfinalabr[,1] == 0.50,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,6]+basinsfinalabr[basinsfinalabr[,1] == 1,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#mixed mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,8] + basinsfinalabr[basinsfinalabr[,1] == 0.05,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "mixed mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,8] + basinsfinalabr[basinsfinalabr[,1] == 0.10,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,8] + basinsfinalabr[basinsfinalabr[,1] == 0.25,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,8] + basinsfinalabr[basinsfinalabr[,1] == 0.50,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,8]+basinsfinalabr[basinsfinalabr[,1] == 1,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))
pdf("AllHeatMapsOrganizedbyEqui_moreabr6equi_reordered_lessthan45_wzero.pdf")#
par(mfrow = c(4,5))#
#
#double high coral#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))#
#
#double high macroalgae#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighM1M2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#pure mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,6] + basinsfinalabr[basinsfinalabr[,1] == 0.05,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "Pure mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,6] + basinsfinalabr[basinsfinalabr[,1] == 0.10,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,6] + basinsfinalabr[basinsfinalabr[,1] == 0.25,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,6] + basinsfinalabr[basinsfinalabr[,1] == 0.50,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,6]+basinsfinalabr[basinsfinalabr[,1] == 1,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#mixed mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,8] + basinsfinalabr[basinsfinalabr[,1] == 0.05,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "mixed mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,8] + basinsfinalabr[basinsfinalabr[,1] == 0.10,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,8] + basinsfinalabr[basinsfinalabr[,1] == 0.25,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,8] + basinsfinalabr[basinsfinalabr[,1] == 0.50,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,8]+basinsfinalabr[basinsfinalabr[,1] == 1,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
dev.off()
par(mfrow = c(3,5))#
#
#double high coral#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))#
#
#double high macroalgae#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighM1M2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#all mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,6] + basinsfinalabr[basinsfinalabr[,1] == 0.05,7]+basinsfinalabr[basinsfinalabr[,1] == 0.05,8]+basinsfinalabr[basinsfinalabr[,1] == 0.05,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "All mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,6] + basinsfinalabr[basinsfinalabr[,1] == 0.10,7]+basinsfinalabr[basinsfinalabr[,1] == 0.10,8]+basinsfinalabr[basinsfinalabr[,1] == 0.10,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,6] + basinsfinalabr[basinsfinalabr[,1] == 0.25,7]+basinsfinalabr[basinsfinalabr[,1] == 0.25,8]+basinsfinalabr[basinsfinalabr[,1] == 0.25,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,6] + basinsfinalabr[basinsfinalabr[,1] == 0.50,7]+basinsfinalabr[basinsfinalabr[,1] == 0.50,8]+basinsfinalabr[basinsfinalabr[,1] == 0.50,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,6]+basinsfinalabr[basinsfinalabr[,1] == 1,7]+basinsfinalabr[basinsfinalabr[,1] == 1,8]+basinsfinalabr[basinsfinalabr[,1] == 1,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))
pdf("AllHeatMapsOrganizedbyEqui_moreabr6equi_reordered_lessthan45_wzero_allmismatch.pdf")#
par(mfrow = c(3,5))#
#
#double high coral#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))#
#
#double high macroalgae#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighM1M2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#all mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,6] + basinsfinalabr[basinsfinalabr[,1] == 0.05,7]+basinsfinalabr[basinsfinalabr[,1] == 0.05,8]+basinsfinalabr[basinsfinalabr[,1] == 0.05,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "All mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,6] + basinsfinalabr[basinsfinalabr[,1] == 0.10,7]+basinsfinalabr[basinsfinalabr[,1] == 0.10,8]+basinsfinalabr[basinsfinalabr[,1] == 0.10,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,6] + basinsfinalabr[basinsfinalabr[,1] == 0.25,7]+basinsfinalabr[basinsfinalabr[,1] == 0.25,8]+basinsfinalabr[basinsfinalabr[,1] == 0.25,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,6] + basinsfinalabr[basinsfinalabr[,1] == 0.50,7]+basinsfinalabr[basinsfinalabr[,1] == 0.50,8]+basinsfinalabr[basinsfinalabr[,1] == 0.50,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,6]+basinsfinalabr[basinsfinalabr[,1] == 1,7]+basinsfinalabr[basinsfinalabr[,1] == 1,8]+basinsfinalabr[basinsfinalabr[,1] == 1,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
dev.off()
save(basinsfinalboth,file="basinsfinalboth.RData")
library(rgdal)#
#
#read 50 reefs data in (from Marco)#
fiftyreefsdata <- readOGR("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/DatafromMarco/reef_cells_allstat/reef_cells_allstat.shp")#
#it's a spatial data frame#
#str(fiftyreefsdata@data)#
#order of scores: thermal stress history metrics (13), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
orig_data <- fiftyreefsdata@data#
head(orig_data)#
#
load('~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/reefs_R_dataframe.rdata')#
head(reefs.df$score) #this is the data that Hawthorne sent, his IDs are different and it's not a shape file (will have to deal with that later, or wait for him to send me the geospatial data bc ill need to have the shape file eventually? can i insert this into the shape file above? not sure) - I need to use this dataframe and not the one from Marco to re-calculate the scores because the 50reefs people took >47000 unique combinations - each time taking one particular metric from each theme...with each unique combination they summed over all 38 weighting schemes and then summed over all unique combinations#
dim(reefs.df)#
#write.table(reefs.df,file=paste0("reefsdf.csv"),sep=",")#
reefs.df.stdized <- unname(reefs.df) #removes the column names#
reefs.df.stdized <- as.matrix(reefs.df.stdized) #these two rows were to avoid the for loops below and be able to just use Row or Col sum but it didn't work for some reason#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
	reefs.df.stdized[,i] <- -reefs.df.stdized[,i] #'sign changed such that higher values are more desirable'#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(-reefs.df.stdized[,176:178]) #because had the right sign to begin with#
#
#12.26.2019 - add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm))
library(rgdal)#
#
#read 50 reefs data in (from Marco)#
fiftyreefsdata <- readOGR("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/DatafromMarco/reef_cells_allstat/reef_cells_allstat.shp")#
#it's a spatial data frame#
#str(fiftyreefsdata@data)#
#order of scores: thermal stress history metrics (13), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
orig_data <- fiftyreefsdata@data#
head(orig_data)#
#
load('~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/reefs_R_dataframe.rdata')#
head(reefs.df$score) #this is the data that Hawthorne sent, his IDs are different and it's not a shape file (will have to deal with that later, or wait for him to send me the geospatial data bc ill need to have the shape file eventually? can i insert this into the shape file above? not sure) - I need to use this dataframe and not the one from Marco to re-calculate the scores because the 50reefs people took >47000 unique combinations - each time taking one particular metric from each theme...with each unique combination they summed over all 38 weighting schemes and then summed over all unique combinations#
dim(reefs.df)#
#write.table(reefs.df,file=paste0("reefsdf.csv"),sep=",")#
reefs.df.stdized <- unname(reefs.df) #removes the column names#
reefs.df.stdized <- as.matrix(reefs.df.stdized) #these two rows were to avoid the for loops below and be able to just use Row or Col sum but it didn't work for some reason#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
	reefs.df.stdized[,i] <- -reefs.df.stdized[,i] #'sign changed such that higher values are more desirable'#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(-reefs.df.stdized[,176:178]) #because had the right sign to begin with#
#
#12.26.2019 - add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
weights<- read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/metric_weights.csv")#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm))
head(redo_ogscaledscore_dadm)
head(reefs.df)
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(reefs.df.stdized[,176:178]) #
#
#12.26.2019 - add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
weights<- read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/metric_weights.csv")#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm))
head(redo_ogscaledscore_dadm)
head(reefs.df[,4])
names(reefs.df)
#read 50 reefs data in (from Marco)#
fiftyreefsdata <- readOGR("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/DatafromMarco/reef_cells_allstat/reef_cells_allstat.shp")#
#it's a spatial data frame#
#str(fiftyreefsdata@data)#
#order of scores: thermal stress history metrics (13), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
orig_data <- fiftyreefsdata@data#
head(orig_data)#
#
load('~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/reefs_R_dataframe.rdata')#
head(reefs.df$score) #this is the data that Hawthorne sent, his IDs are different and it's not a shape file (will have to deal with that later, or wait for him to send me the geospatial data bc ill need to have the shape file eventually? can i insert this into the shape file above? not sure) - I need to use this dataframe and not the one from Marco to re-calculate the scores because the 50reefs people took >47000 unique combinations - each time taking one particular metric from each theme...with each unique combination they summed over all 38 weighting schemes and then summed over all unique combinations#
dim(reefs.df)#
#write.table(reefs.df,file=paste0("reefsdf.csv"),sep=",")#
reefs.df.stdized <- unname(reefs.df) #removes the column names#
reefs.df.stdized <- as.matrix(reefs.df.stdized) #these two rows were to avoid the for loops below and be able to just use Row or Col sum but it didn't work for some reason#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
	reefs.df.stdized[,i] <- -reefs.df.stdized[,i] #'sign changed such that higher values are more desirable'#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(reefs.df.stdized[,176:178]) #
#
#12.26.2019 - add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
weights<- read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/metric_weights.csv")#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm))
head(redo_ogscaledscore_dadm)#
head(reefs.df[,4])
#read 50 reefs data in (from Marco)#
fiftyreefsdata <- readOGR("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/DatafromMarco/reef_cells_allstat/reef_cells_allstat.shp")#
#it's a spatial data frame#
#str(fiftyreefsdata@data)#
#order of scores: thermal stress history metrics (13), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
orig_data <- fiftyreefsdata@data#
head(orig_data)#
#
load('~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/reefs_R_dataframe.rdata')#
head(reefs.df$score) #this is the data that Hawthorne sent, his IDs are different and it's not a shape file (will have to deal with that later, or wait for him to send me the geospatial data bc ill need to have the shape file eventually? can i insert this into the shape file above? not sure) - I need to use this dataframe and not the one from Marco to re-calculate the scores because the 50reefs people took >47000 unique combinations - each time taking one particular metric from each theme...with each unique combination they summed over all 38 weighting schemes and then summed over all unique combinations#
dim(reefs.df)#
#write.table(reefs.df,file=paste0("reefsdf.csv"),sep=",")#
reefs.df.stdized <- unname(reefs.df) #removes the column names#
reefs.df.stdized <- as.matrix(reefs.df.stdized) #these two rows were to avoid the for loops below and be able to just use Row or Col sum but it didn't work for some reason#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
	#reefs.df.stdized[,i] <- -reefs.df.stdized[,i] #'sign changed such that higher values are more desirable'#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(reefs.df.stdized[,176:178]) #
#
#12.26.2019 - add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
weights<- read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/metric_weights.csv")#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm))#
head(redo_ogscaledscore_dadm)#
head(reefs.df[,4])
load('~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/reefs_R_dataframe.rdata') #the data sent by Hawthorne#
#head(reefs.df) #
#dim(reefs.df)#
#
#making the data mean 0, s.d. 1#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#switching the signs of all but the connectivity metrics to make it so 'higher values are more desirable'#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(-reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(-reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(-reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(-reefs.df.stdized[,176:178]) #
#
#------#Score Calculation Method 1 (this generates the same scores as the other methods)#
#Note to Hawthorne: this is the fastest way to calculate the scores, but it's a bit complicated to explain why it is doing the same thing as the other more direct methods of calculating the scores (I can send you a powerpoint explaining it if you wish but it's kind of long)#
#add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
weights<- read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/metric_weights.csv") #the weights excel file you sent (38 rows, 5 columns)#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm)) #dividing all of the scores by the max absolute value score#
#
head(redo_ogscaledscore_dadm) #scores i calculated#
head(reefs.df[,4]) #scores calculated by Hawthorne
load('~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/reefs_R_dataframe.rdata') #the data sent by Hawthorne#
#head(reefs.df) #
#dim(reefs.df)#
#
#making the data mean 0, s.d. 1#
reefs.df.stdized <- reefs.df#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#switching the signs of all but the connectivity metrics to make it so 'higher values are more desirable'#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(-reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(-reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(-reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(-reefs.df.stdized[,176:178]) #
#
#------#Score Calculation Method 1 (this generates the same scores as the other methods)#
#Note to Hawthorne: this is the fastest way to calculate the scores, but it's a bit complicated to explain why it is doing the same thing as the other more direct methods of calculating the scores (I can send you a powerpoint explaining it if you wish but it's kind of long)#
#add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
weights<- read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/metric_weights.csv") #the weights excel file you sent (38 rows, 5 columns)#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm)) #dividing all of the scores by the max absolute value score#
#
head(redo_ogscaledscore_dadm) #scores i calculated#
head(reefs.df[,4]) #scores calculated by Hawthorne
reefs.df <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/FixedData_1.20.2020/50Reefs_data/tabular/50Reefs_dataset.csv")
head(reefs.df)
dim(reefs.df)#
#write.table(reefs.df,file=paste0("reefsdf.csv"),sep=",")#
reefs.df.stdized <- unname(reefs.df) #removes the column names#
reefs.df.stdized <- as.matrix(reefs.df.stdized) #these two rows were to avoid the for loops below and be able to just use Row or Col sum but it didn't work for some reason#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
	reefs.df.stdized[,i] <- -reefs.df.stdized[,i] #'sign changed such that higher values are more desirable' #did it so higher values are bad and that didn't work either#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(reefs.df.stdized[,176:178]) #
#
#12.26.2019 - add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}
weights<-read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/FixedData_1.20.2020/50Reefs_data/tabular/metric_weights.csv")#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm))
head(redo_ogscaledscore_dadm)#
head(reefs.df[,4])
load('~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/reefs_R_dataframe.rdata')
newreefs.df <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/FixedData_1.20.2020/50Reefs_data/tabular/50Reefs_dataset.csv")
head(reefs.df$score)#
head(newreefs.df$score)
reefs.df <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/FixedData_1.20.2020/50Reefs_data/tabular/50Reefs_dataset.csv")#
head(reefs.df)#
#
dim(reefs.df)#
#write.table(reefs.df,file=paste0("reefsdf.csv"),sep=",")#
reefs.df.stdized <- unname(reefs.df) #removes the column names#
reefs.df.stdized <- as.matrix(reefs.df.stdized) #these two rows were to avoid the for loops below and be able to just use Row or Col sum but it didn't work for some reason#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
	reefs.df.stdized[,i] <- -reefs.df.stdized[,i] #'sign changed such that higher values are more desirable' #did it so higher values are bad and that didn't work either#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(-reefs.df.stdized[,176:178]) #
#
#12.26.2019 - add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
#weights<- read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/metric_weights.csv")#
#new data:#
weights<-read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/FixedData_1.20.2020/50Reefs_data/tabular/metric_weights.csv")#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm))
head(redo_ogscaledscore_dadm)#
head(reefs.df[,4])
reefs.df <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/FixedData_1.20.2020/50Reefs_data/tabular/50Reefs_dataset.csv")#
head(reefs.df)#
#
dim(reefs.df)#
#write.table(reefs.df,file=paste0("reefsdf.csv"),sep=",")#
reefs.df.stdized <- unname(reefs.df) #removes the column names#
reefs.df.stdized <- as.matrix(reefs.df.stdized) #these two rows were to avoid the for loops below and be able to just use Row or Col sum but it didn't work for some reason#
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
	reefs.df.stdized[,i] <- -reefs.df.stdized[,i] #'sign changed such that higher values are more desirable' #did it so higher values are bad and that didn't work either#
}#
#
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
#cyc_met <- as.matrix(-reefs.df.stdized[,176:178]) #this one apparently flips too..#
cyc_met <- as.matrix(reefs.df.stdized[,176:178])#
cyc_met[,3] <- -cyc_met[,3]#
#
#12.26.2019 - add up all of the numbers in each theme for each reef, multiply each of the themes by the number of values in each of the other themes and then multiply that by w#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}#
#weights<- read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/metric_weights.csv")#
#new data:#
weights<-read.csv("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/FixedData_1.20.2020/50Reefs_data/tabular/metric_weights.csv")#
redo_ogsum_onescheme_dadm <- rep(NA,dim(weights)[1])#
redo_ogsum_onemet_dadm <- rep(NA, 47424)#
#redo_ogsum_onemet <- matrix(data = NA, nrow= 47424, ncol = dim(reefs.df)[1])#
redo_ogunscaledscore_dadm <- rep(NA, dim(reefs.df.stdized)[1])#
for(i in 1:dim(reefs.df)[1]){#
print(paste("i = ",i))#
	for(j in 1:dim(weights)[1]){#
redo_ogsum_onemet_dadm <- as.numeric(weights[j,1]*(tspnum*rtcnum*connnum*cycnum)*tsh_num[i] + weights[j,2]*(tshnum*rtcnum*connnum*cycnum)*tsp_num[i] + weights[j,3]*(tshnum*tspnum*connnum*cycnum)*rtc_num[i] + weights[j,4]*(tshnum*tspnum*rtcnum*cycnum)*conn_num[i]  + weights[j,5]*(tshnum*tspnum*rtcnum*connnum)*cyc_num[i])#
redo_ogsum_onescheme_dadm[j] <- sum(redo_ogsum_onemet_dadm)#
}#
redo_ogunscaledscore_dadm[i] <- sum(redo_ogsum_onescheme_dadm)#
}#
redo_ogscaledscore_dadm <- redo_ogunscaledscore_dadm/max(abs(redo_ogunscaledscore_dadm))#
head(redo_ogscaledscore_dadm)#
head(reefs.df[,4])
load('~/Documents/computecanadajune2019/didntfinish_trajectoriestorecalc.RData')
head(didntfinish)
1 %in% c(2,3,4,5)
1 %in% c(2,3,4,5,1)
library(scales)#
library(deSolve)#
library(fields)#
#load + compile data#
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Unequal coral macroalgal dispersal/twopatch_ext_unequal_complete_IDs.RData')#
twopatch_ext_unequal_complete_IDs$colour <- NULL#
#need to add twopatch_ext_complete_IDs in#
load('~/Documents/computecanadajune2019/twopatch_ext_complete_IDs.RData') #probably should replace this with a link to something in dropbox#
twopatch_ext_complete_IDs$symbol <- NULL#
twopatch_ext_complete_IDs$percentofcoral <- 100#
#
twopatch_ext_complete <- rbind(twopatch_ext_complete_IDs,twopatch_ext_unequal_complete_IDs)#
#
#to get rid of floating point errors#
twopatch_ext_complete$percentofcoral <- round(twopatch_ext_complete$percentofcoral, digits = 0)#
#levels(as.factor(twopatch_ext_complete$p_m)) 4 decimal points is the longest#
twopatch_ext_complete$p_m <- round(twopatch_ext_complete$p_m,4)#
twopatch_ext_complete$q_m <- round(twopatch_ext_complete$q_m,4)#
#basinofattractionID <- might not do anything with this bc no longer plotting BOAs but if ever do, can use these#
#should put all of the basinsabr dataframes into one big dataframe...or matrix to make looping easier#
lvls <- c(rep(1,99*99),rep(0.05,99*99),rep(0.1,99*99),rep(0.25,99*99),rep(0.5,99*99))#
grazing <- c(rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99))#
recruit <-c(rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99))#
sum <- rep(NA,length(lvls)) #wasnt here when i ran it...#
equitypeone <- equitypetwo <- equitypethree <- equitypefour <- equitypefive <- equitypesix <- rep(0,length(lvls))#
exist <- rep(-1,length(lvls)) #-1 if still need to load in basins file, 0 if don't#
basinsfinal <-  matrix(c(lvls,grazing,recruit,equitypeone,equitypetwo,equitypethree,equitypefour,equitypefive,equitypesix,sum),nrow=length(lvls),ncol=10)#
#
#equitypeone: high equal coral both patches, equitypetwo: high equal macroalgae both patches, equitypethree: High C1 High M2 C2=M1=0, equitypefour: High C2 High M1 C1=M2=0, equitypefive: High C1 High M2 C2>0 M1>0, equitypesix: High C2 High M1 C1>0 M2>0#
basinsabr <- 0#
#errors with: i = 1-12 don't seem to exist, did 20-496, re-started at 7999 (double check this one) and then again at 49005 (double check also)..oh nvmnd it's done..still double check 7999 - it looks fine #UPDATE: added in 1-12#
stopp = 500#
load('~/Documents/computecanadajune2019/didntfinish_trajectoriestorecalc.RData') #
head(didntfinish)#
for(i in 1:length(lvls)){#
print(paste("i =",i))#
lvl <- basinsfinal[i,1]		#
g_val <- basinsfinal[i,2]	#
recruitvalue <- recruit <- basinsfinal[i,3]	#
#load in relevant basinsabr file...apparently not all of them exist...#
load(paste0("~/Documents/computecanadajune2019/sept2019run/bsns_better_abr/basins_recr",recruitvalue,"g",g_val,"_",lvl*100,"percentofcoral_5850.RData"))#
if(lvl %in% didntfinish[,1] & g_val %in% didntfinish[,2] & recruitvalue %in% didntfinish[,3]){#
	basinsabr <- 0 #clear it, just in case#
	load(paste0("~/Documents/computecanadajune2019/extralongtraj_SMALL/bsns_better_abr2/basins_recr",recruitvalue,"g",g_val,"_",lvl*100,"percentofcoral_10000.RData"))#
}#
for(j in 1:100){ #bc set to 100 diff possible ID values#
print(paste("j =",j))#
if(basinsabr$Size[basinsabr$EquilibriumID == j] > 0){#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,4] <- (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #only one of these equi per paramcombo#
}#
#
if((twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,5] <- (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #only one of these equi per paramcombo#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == 0)){#
basinsfinal[i,6] <- basinsfinal[i,6] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] < twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4)& twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == 0)){#
basinsfinal[i,7] <- basinsfinal[i,7] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,8] <- basinsfinal[i,8] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] < twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4)& twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,9] <- basinsfinal[i,9] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
}}	#
#
basinsfinal[i,10] <- basinsfinal[i,4]+basinsfinal[i,5]+basinsfinal[i,6]+basinsfinal[i,7] + basinsfinal[i,8]+basinsfinal[i,9]#
#
if(i == stopp){#
save(basinsfinal, file = paste0("basinsfinal_",stopp,".RData"))#
stopp = stopp + 1000#
}#
basinsabr <- 0 #clear it, just in case#
}
lvl
g_val
recruitvalue
c(didntfinish[,1],didntfinish[,2],didntfinish[,3])
didntfinish[,1]*100000 + didntfinish[,2]*1000 + didntfinish[,3]*1
didntfinish[,1]*1000000 + didntfinish[,2]*1000 + didntfinish[,3]*1
library(scales)#
library(deSolve)#
library(fields)#
#load + compile data#
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Unequal coral macroalgal dispersal/twopatch_ext_unequal_complete_IDs.RData')#
twopatch_ext_unequal_complete_IDs$colour <- NULL#
#need to add twopatch_ext_complete_IDs in#
load('~/Documents/computecanadajune2019/twopatch_ext_complete_IDs.RData') #probably should replace this with a link to something in dropbox#
twopatch_ext_complete_IDs$symbol <- NULL#
twopatch_ext_complete_IDs$percentofcoral <- 100#
#
twopatch_ext_complete <- rbind(twopatch_ext_complete_IDs,twopatch_ext_unequal_complete_IDs)#
#
#to get rid of floating point errors#
twopatch_ext_complete$percentofcoral <- round(twopatch_ext_complete$percentofcoral, digits = 0)#
#levels(as.factor(twopatch_ext_complete$p_m)) 4 decimal points is the longest#
twopatch_ext_complete$p_m <- round(twopatch_ext_complete$p_m,4)#
twopatch_ext_complete$q_m <- round(twopatch_ext_complete$q_m,4)#
#basinofattractionID <- might not do anything with this bc no longer plotting BOAs but if ever do, can use these#
#should put all of the basinsabr dataframes into one big dataframe...or matrix to make looping easier#
lvls <- c(rep(1,99*99),rep(0.05,99*99),rep(0.1,99*99),rep(0.25,99*99),rep(0.5,99*99))#
grazing <- c(rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99))#
recruit <-c(rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99))#
sum <- rep(NA,length(lvls)) #wasnt here when i ran it...#
equitypeone <- equitypetwo <- equitypethree <- equitypefour <- equitypefive <- equitypesix <- rep(0,length(lvls))#
exist <- rep(-1,length(lvls)) #-1 if still need to load in basins file, 0 if don't#
basinsfinal <-  matrix(c(lvls,grazing,recruit,equitypeone,equitypetwo,equitypethree,equitypefour,equitypefive,equitypesix,sum),nrow=length(lvls),ncol=10)#
#
#equitypeone: high equal coral both patches, equitypetwo: high equal macroalgae both patches, equitypethree: High C1 High M2 C2=M1=0, equitypefour: High C2 High M1 C1=M2=0, equitypefive: High C1 High M2 C2>0 M1>0, equitypesix: High C2 High M1 C1>0 M2>0#
basinsabr <- 0#
#errors with: i = 1-12 don't seem to exist, did 20-496, re-started at 7999 (double check this one) and then again at 49005 (double check also)..oh nvmnd it's done..still double check 7999 - it looks fine #UPDATE: added in 1-12#
stopp = 500#
load('~/Documents/computecanadajune2019/didntfinish_trajectoriestorecalc.RData') #
head(didntfinish)#
#
for(i in 1:length(lvls)){#
print(paste("i =",i))#
lvl <- basinsfinal[i,1]		#
g_val <- basinsfinal[i,2]	#
recruitvalue <- recruit <- basinsfinal[i,3]	#
#load in relevant basinsabr file...apparently not all of them exist...#
load(paste0("~/Documents/computecanadajune2019/sept2019run/bsns_better_abr/basins_recr",recruitvalue,"g",g_val,"_",lvl*100,"percentofcoral_5850.RData"))#
if(lvl*1000000 + g_val*1000 + recruitvalue*1 %in% didntfinish[,1]*1000000 + didntfinish[,2]*1000 + didntfinish[,3]*1){#
	basinsabr <- 0 #clear it, just in case#
	load(paste0("~/Documents/computecanadajune2019/extralongtraj_SMALL/bsns_better_abr2/basins_recr",recruitvalue,"g",g_val,"_",lvl*100,"percentofcoral_10000.RData"))#
}#
for(j in 1:100){ #bc set to 100 diff possible ID values#
print(paste("j =",j))#
if(basinsabr$Size[basinsabr$EquilibriumID == j] > 0){#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,4] <- (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #only one of these equi per paramcombo#
}#
#
if((twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,5] <- (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #only one of these equi per paramcombo#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == 0)){#
basinsfinal[i,6] <- basinsfinal[i,6] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] < twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4)& twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == 0)){#
basinsfinal[i,7] <- basinsfinal[i,7] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,8] <- basinsfinal[i,8] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] < twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4)& twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,9] <- basinsfinal[i,9] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
}}	#
#
basinsfinal[i,10] <- basinsfinal[i,4]+basinsfinal[i,5]+basinsfinal[i,6]+basinsfinal[i,7] + basinsfinal[i,8]+basinsfinal[i,9]#
#
if(i == stopp){#
save(basinsfinal, file = paste0("basinsfinal_",stopp,".RData"))#
stopp = stopp + 1000#
}#
basinsabr <- 0 #clear it, just in case#
}#
#check: #
#sum(rowSums(basinsfinal[,4:7]) == 100) #47299 so not all of them = 100#
#troule <- c(1:49005)#
#troule[which(rowSums(basinsfinal[,4:7]) < 100)]#
save(basinsfinal,file="basinsfinal_done.RData")
library(scales)#
library(deSolve)#
library(fields)#
#load + compile data#
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Unequal coral macroalgal dispersal/twopatch_ext_unequal_complete_IDs.RData')#
twopatch_ext_unequal_complete_IDs$colour <- NULL#
#need to add twopatch_ext_complete_IDs in#
load('~/Documents/computecanadajune2019/twopatch_ext_complete_IDs.RData') #probably should replace this with a link to something in dropbox#
twopatch_ext_complete_IDs$symbol <- NULL#
twopatch_ext_complete_IDs$percentofcoral <- 100#
#
twopatch_ext_complete <- rbind(twopatch_ext_complete_IDs,twopatch_ext_unequal_complete_IDs)#
#
#to get rid of floating point errors#
twopatch_ext_complete$percentofcoral <- round(twopatch_ext_complete$percentofcoral, digits = 0)#
#levels(as.factor(twopatch_ext_complete$p_m)) 4 decimal points is the longest#
twopatch_ext_complete$p_m <- round(twopatch_ext_complete$p_m,4)#
twopatch_ext_complete$q_m <- round(twopatch_ext_complete$q_m,4)#
#basinofattractionID <- might not do anything with this bc no longer plotting BOAs but if ever do, can use these#
#should put all of the basinsabr dataframes into one big dataframe...or matrix to make looping easier#
lvls <- c(rep(1,99*99),rep(0.05,99*99),rep(0.1,99*99),rep(0.25,99*99),rep(0.5,99*99))#
grazing <- c(rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99))#
recruit <-c(rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99))#
sum <- rep(NA,length(lvls)) #wasnt here when i ran it...#
equitypeone <- equitypetwo <- equitypethree <- equitypefour <- equitypefive <- equitypesix <- rep(0,length(lvls))#
exist <- rep(-1,length(lvls)) #-1 if still need to load in basins file, 0 if don't#
basinsfinal <-  matrix(c(lvls,grazing,recruit,equitypeone,equitypetwo,equitypethree,equitypefour,equitypefive,equitypesix,sum),nrow=length(lvls),ncol=10)#
#
#equitypeone: high equal coral both patches, equitypetwo: high equal macroalgae both patches, equitypethree: High C1 High M2 C2=M1=0, equitypefour: High C2 High M1 C1=M2=0, equitypefive: High C1 High M2 C2>0 M1>0, equitypesix: High C2 High M1 C1>0 M2>0#
basinsabr <- 0#
#errors with: i = 1-12 don't seem to exist, did 20-496, re-started at 7999 (double check this one) and then again at 49005 (double check also)..oh nvmnd it's done..still double check 7999 - it looks fine #UPDATE: added in 1-12#
stopp = 500#
load('~/Documents/computecanadajune2019/didntfinish_trajectoriestorecalc.RData') #
head(didntfinish)#
#
for(i in 1:length(lvls)){#
print(paste("i =",i))#
lvl <- basinsfinal[i,1]		#
g_val <- basinsfinal[i,2]	#
recruitvalue <- recruit <- basinsfinal[i,3]	#
#load in relevant basinsabr file...apparently not all of them exist...#
load(paste0("~/Documents/computecanadajune2019/sept2019run/bsns_better_abr/basins_recr",recruitvalue,"g",g_val,"_",lvl*100,"percentofcoral_5850.RData"))#
if((lvl*1000000 + g_val*1000 + recruitvalue*1) %in% (didntfinish[,1]*1000000 + didntfinish[,2]*1000 + didntfinish[,3]*1)){#
	basinsabr <- 0 #clear it, just in case#
	load(paste0("~/Documents/computecanadajune2019/extralongtraj_SMALL/bsns_better_abr2/basins_recr",recruitvalue,"g",g_val,"_",lvl*100,"percentofcoral_10000.RData"))#
}#
for(j in 1:100){ #bc set to 100 diff possible ID values#
print(paste("j =",j))#
if(basinsabr$Size[basinsabr$EquilibriumID == j] > 0){#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,4] <- (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #only one of these equi per paramcombo#
}#
#
if((twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,5] <- (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #only one of these equi per paramcombo#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == 0)){#
basinsfinal[i,6] <- basinsfinal[i,6] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] < twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4)& twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] == 0)){#
basinsfinal[i,7] <- basinsfinal[i,7] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,8] <- basinsfinal[i,8] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] < twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4)& twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == round(recruit,4) & twopatch_ext_complete$q_m == round(recruit*lvl,4) & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,9] <- basinsfinal[i,9] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
}}	#
#
basinsfinal[i,10] <- basinsfinal[i,4]+basinsfinal[i,5]+basinsfinal[i,6]+basinsfinal[i,7] + basinsfinal[i,8]+basinsfinal[i,9]#
#
if(i == stopp){#
save(basinsfinal, file = paste0("basinsfinal_",stopp,".RData"))#
stopp = stopp + 1000#
}#
basinsabr <- 0 #clear it, just in case#
}#
#check: #
#sum(rowSums(basinsfinal[,4:7]) == 100) #47299 so not all of them = 100#
#troule <- c(1:49005)#
#troule[which(rowSums(basinsfinal[,4:7]) < 100)]#
save(basinsfinal,file="basinsfinal_done.RData")
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Unequal coral macroalgal dispersal/Basin of Attraction Work/BoAwork_6equibadversion/basinsfinal_done_6equi_longtrajincl.RData')
library(scales)#
library(deSolve)#
library(fields)#
#load + compile data#
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Unequal coral macroalgal dispersal/twopatch_ext_unequal_complete_IDs.RData')#
twopatch_ext_unequal_complete_IDs$colour <- NULL#
#need to add twopatch_ext_complete_IDs in#
load('~/Documents/computecanadajune2019/twopatch_ext_complete_IDs.RData') #probably should replace this with a link to something in dropbox#
twopatch_ext_complete_IDs$symbol <- NULL#
twopatch_ext_complete_IDs$percentofcoral <- 100#
#
twopatch_ext_complete <- rbind(twopatch_ext_complete_IDs,twopatch_ext_unequal_complete_IDs)#
#
#to get rid of floating point errors#
twopatch_ext_complete$percentofcoral <- round(twopatch_ext_complete$percentofcoral, digits = 0)#
#levels(as.factor(twopatch_ext_complete$p_m)) 4 decimal points is the longest#
twopatch_ext_complete$p_m <- round(twopatch_ext_complete$p_m,4)#
twopatch_ext_complete$q_m <- round(twopatch_ext_complete$q_m,4)#
#basinofattractionID <- might not do anything with this bc no longer plotting BOAs but if ever do, can use these#
#should put all of the basinsabr dataframes into one big dataframe...or matrix to make looping easier#
lvls <- c(rep(1,99*99),rep(0.05,99*99),rep(0.1,99*99),rep(0.25,99*99),rep(0.5,99*99))#
grazing <- c(rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99),rep(seq(0.01,0.99,0.01), each = 99))#
recruit <-c(rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99),rep(seq(0.01,0.99,0.01), 99))#
sum <- rep(NA,length(lvls)) #wasnt here when i ran it...#
equitypeone <- equitypetwo <- equitypethree <- equitypefour <- equitypefive <- equitypesix <- rep(0,length(lvls))#
exist <- rep(-1,length(lvls)) #-1 if still need to load in basins file, 0 if don't
load('~/Documents/computecanadajune2019/didntfinish_trajectoriestorecalc.RData') #
head(didntfinish)
sum(basinsfinal[,10] == 100)
basinsfinal[which(round(basinsfinal[,10],4) < 100),]
sum(basinsfinal[,10])
didntfinish
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/zero dispersal/basinsfinalzero_done.RData')
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Unequal coral macroalgal dispersal/Basin of Attraction Work/BoAwork_6equibadversion/basinsfinal_done_6equi_longtrajincl.RData')#
head(basinsfinal)#
#basinsfinalzero#
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/zero dispersal/basinsfinalzero_done.RData')#
head(basinsfinalzero)#
#
#need to put the basinsfinal and basinsfinalzero dataframes together#
equal_basinsfinalzero <- basinsfinalzero#
five_basinsfinalzero <- ten_basinsfinalzero <- twentyfive_basinsfinalzero <- fifty_basinsfinalzero <- basinsfinalzero #want a zero in every graph#
equal_basinsfinalzero[,1] <- 1#
five_basinsfinalzero[,1] <- 0.05#
ten_basinsfinalzero[,1] <- 0.10#
twentyfive_basinsfinalzero[,1] <- 0.25#
fifty_basinsfinalzero[,1] <- 0.50#
#
basinsfinalzero_all <- rbind(equal_basinsfinalzero,five_basinsfinalzero,ten_basinsfinalzero,twentyfive_basinsfinalzero,fifty_basinsfinalzero)#
#make empty matrix where every different 'g' and diff dispersal inequality level have a zero disp case#
lvls <- c(rep(1,100*99),rep(0.05,100*99),rep(0.1,100*99),rep(0.25,100*99),rep(0.5,100*99))#
grazing <- c(rep(seq(0.01,0.99,0.01), each = 100),rep(seq(0.01,0.99,0.01), each = 100),rep(seq(0.01,0.99,0.01), each = 100),rep(seq(0.01,0.99,0.01), each = 100),rep(seq(0.01,0.99,0.01), each = 100))#
recruit <-c(rep(seq(0,0.99,0.01), 99),rep(seq(0,0.99,0.01), 99),rep(seq(0,0.99,0.01), 99),rep(seq(0,0.99,0.01), 99),rep(seq(0,0.99,0.01), 99))#
sum <- rep(NA,length(lvls)) #wasnt here when i ran it...#
equitypeone <- equitypetwo <- equitypethree <- equitypefour <- equitypefive <- equitypesix <- rep(0,length(lvls))#
exist <- rep(-1,length(lvls)) #-1 if still need to load in basins file, 0 if don't#
basinsfinalboth <-  matrix(c(lvls,grazing,recruit,equitypeone,equitypetwo,equitypethree,equitypefour,equitypefive,equitypesix,sum),nrow=length(lvls),ncol=10)#
#
for(i in 1:(dim(basinsfinalzero_all)[1])){#
basinsfinalboth[(1+((i-1)*100)),] <- basinsfinalzero_all[i,]	#
basinsfinalboth[(1+((i-1)*100)+1):(1+((i-1)*100)+99),] <- basinsfinal[(((i-1)*99)+1):((i)*99),]#
}#
save(basinsfinalboth,file="basinsfinalboth.RData")
basinsfinalabr <- basinsfinalboth[basinsfinalboth[,3] <= 0.45,]  #bc Marty wanted to make the heatmaps ignoring the coral dispersal values greater than 0.4 bc nothing happens above that#
#
#RAINBOW VERSION (abridged, mixed+pure mismatch)#
pdf("AllHeatMapsOrganizedbyEqui_moreabr6equi_reordered_lessthan45_wzero_allmismatch.pdf")#
par(mfrow = c(3,5))#
#
#double high coral#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))#
#
#double high macroalgae#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighM1M2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#all mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,6] + basinsfinalabr[basinsfinalabr[,1] == 0.05,7]+basinsfinalabr[basinsfinalabr[,1] == 0.05,8]+basinsfinalabr[basinsfinalabr[,1] == 0.05,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "All mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,6] + basinsfinalabr[basinsfinalabr[,1] == 0.10,7]+basinsfinalabr[basinsfinalabr[,1] == 0.10,8]+basinsfinalabr[basinsfinalabr[,1] == 0.10,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,6] + basinsfinalabr[basinsfinalabr[,1] == 0.25,7]+basinsfinalabr[basinsfinalabr[,1] == 0.25,8]+basinsfinalabr[basinsfinalabr[,1] == 0.25,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,6] + basinsfinalabr[basinsfinalabr[,1] == 0.50,7]+basinsfinalabr[basinsfinalabr[,1] == 0.50,8]+basinsfinalabr[basinsfinalabr[,1] == 0.50,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,6]+basinsfinalabr[basinsfinalabr[,1] == 1,7]+basinsfinalabr[basinsfinalabr[,1] == 1,8]+basinsfinalabr[basinsfinalabr[,1] == 1,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
dev.off()#
#RAINBOW VERSION (abridged)  #
pdf("AllHeatMapsOrganizedbyEqui_moreabr6equi_reordered_lessthan45_wzero.pdf")#
par(mfrow = c(4,5))#
#
#double high coral#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,4], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100))#
#
#double high macroalgae#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighM1M2, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,5], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#pure mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,6] + basinsfinalabr[basinsfinalabr[,1] == 0.05,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "Pure mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,6] + basinsfinalabr[basinsfinalabr[,1] == 0.10,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,6] + basinsfinalabr[basinsfinalabr[,1] == 0.25,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,6] + basinsfinalabr[basinsfinalabr[,1] == 0.50,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,6]+basinsfinalabr[basinsfinalabr[,1] == 1,7], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
#mixed mismatch#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.05,8] + basinsfinalabr[basinsfinalabr[,1] == 0.05,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "mixed mismatch, 5%",zlim=c(0,100), ylim = c(0,0.45))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.10,8] + basinsfinalabr[basinsfinalabr[,1] == 0.10,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "10%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.25,8] + basinsfinalabr[basinsfinalabr[,1] == 0.25,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "25%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 0.50,8] + basinsfinalabr[basinsfinalabr[,1] == 0.50,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "50%",zlim=c(0,100))#
image.plot(t(matrix(basinsfinalabr[basinsfinalabr[,1] == 1,8]+basinsfinalabr[basinsfinalabr[,1] == 1,9], nrow = 46, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "Equal",zlim=c(0,100)) #
#
dev.off()
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Heterogeneous_Grazing/twopatch_ext_heterograz_ID_full.RData')
names(twopatch_ext_heterograz_ID_full)
range(twopatch_ext_heterograz_ID_full$ID)
library(scales)#
library(deSolve)#
library(fields)#
#
#load + compile data#
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Heterogeneous_Grazing/twopatch_ext_heterograz_ID_full.RData')#
twopatch_ext_complete <- twopatch_ext_heterograz_ID_full #range of ID: 0 -> 302 (added in ID 302 to deal with 2855-2900)#
#
#should put all of the basinsabr dataframes into one big dataframe...or matrix to make looping easier#
glvl <- c(rep(0.1,100*99),rep(0.3,100*99),rep(0.5,100*99))#
grazing <- c(rep(seq(0.01,0.99,0.01), each = 100),rep(seq(0.01,0.99,0.01), each = 100),rep(seq(0.01,0.99,0.01), each = 100))#
recruit <-c(rep(seq(0,0.99,0.01), 99),rep(seq(0,0.99,0.01), 99),rep(seq(0,0.99,0.01), 99))#
equitypeone <- equitypetwo <- equitypethree <- equitypefour <- equitypefive <- equitypesix <- equitypeseven <- equitypeeight <- equitypenine <- rep(0,length(glvl))#
summ <- rep(0,length(glvl))#
#exist <- rep(-1,length(glvl)) #-1 if still need to load in basins file, 0 if don't#
basinsfinal <-  matrix(c(glvl,grazing,recruit,equitypeone,equitypetwo,equitypethree,equitypefour,equitypefive,equitypesix, equitypeseven, equitypeeight, equitypenine,summ),nrow=length(glvl),ncol=13)
basinsabr <- 0#
stopp = 500
i <- 2855
glvl <- basinsfinal[i,1]		#
g_val <- basinsfinal[i,2]	#
recruitvalue <- recruit <- round(basinsfinal[i,3],4)#
load(paste0("~/Documents/computecanadajune2019/HeterogeneousGrazing12.2019run/bsns_heteroggrazlong_abr/basins_recr",recruitvalue,"g",g_val,"_glvl",glvl,"_20000.RData"))
glvl
g_val
recruitvalue
i = 2855
glvl <- basinsfinal[i,1]		#
g_val <- basinsfinal[i,2]	#
recruitvalue <- recruit <- round(basinsfinal[i,3],4)#
load(paste0("~/Documents/computecanadajune2019/HeterogeneousGrazing12.2019run/bsns_heteroggrazlong_abr/basins_recr",recruitvalue,"g",g_val,"_glvl",glvl,"_20000.RData"))
glvl
g_val
recruitvalue
i <- 2856
glvl <- basinsfinal[i,1]		#
g_val <- basinsfinal[i,2]	#
recruitvalue <- recruit <- round(basinsfinal[i,3],4)#
load(paste0("~/Documents/computecanadajune2019/HeterogeneousGrazing12.2019run/bsns_heteroggrazlong_abr/basins_recr",recruitvalue,"g",g_val,"_glvl",glvl,"_20000.RData"))
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Heterogeneous_Grazing/hg_basinsfinal_done_alllong.RData')
basinsfinal[2850:2860,]
basinsfinal[2890:2950,]
basinsabr <- 0#
stopp = 500#
#
#i = 2855 STILL not working...so odd - the file doesn't exist still...why#
#i = 2855-2900? still not working - not working because need to fix the ones that follow from the one with no stable node (g = 0.29, recruitvalue = 0.54, glvl = 0.1) as they just have ID = NA. Could give them all ID = 302 bc they all seem to be the same equi and even if it is similar to another it apparently wasn't similar enough#
for(i in 2856:2900){ #1:length(summ)#
print(paste("i =",i))#
glvl <- basinsfinal[i,1]		#
g_val <- basinsfinal[i,2]	#
recruitvalue <- recruit <- round(basinsfinal[i,3],4)#
load(paste0("~/Documents/computecanadajune2019/HeterogeneousGrazing12.2019run/bsns_heteroggrazlong_abr/basins_recr",recruitvalue,"g",g_val,"_glvl",glvl,"_20000.RData"))#
#if(i %in% didntfinish){ #comes from below #OLD: just re-did all of them in the long form#
#load(paste0("~/Documents/computecanadajune2019/HeterogeneousGrazing12.2019run/bsns_heteroggrazlong_abr/basins_recr",recruitvalue,"g",g_val,"_glvl",glvl,"_20000.RData"))#
#}	#
#else{load(paste0("~/Documents/computecanadajune2019/HeterogeneousGrazing12.2019run/bsns_heteroggraz_abr/basins_recr",recruitvalue,"g",g_val,"_glvl",glvl,"_5850.RData"))}#
#
for(j in 1:350){ #bc set to 350 diff possible ID values#
print(paste("j =",j))#
if(basinsabr$Size[basinsabr$EquilibriumID == j] > 0){#
#equitypeone = high coral zero macroalgae both patches - M1=M2=0, C1 >0, C2 > 0#
if((twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == 0) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == 0) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete
$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,4] <-  basinsfinal[i,4] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #
}#
#
#equitypetwo = high macroalgae zero coral both patches - C1=C2=0, M1 >0, M2 > 0#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == 0) & (twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == 0) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete
$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,5] <-  basinsfinal[i,5] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #
}#
#
#equitypethree: High C1 High M2 C2=M1=0 (basically: C2=M1=0, C1 > 0, M2 > 0)#
if((twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == 0) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == 0) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete
$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,6] <-  basinsfinal[i,6] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #
}#
#
#equitypefour: High C2 High M1 C1=M2=0 (basically: M2=C1=0, M1 > 0, C2 > 0)#
if((twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == 0) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == 0) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete
$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0)){#
basinsfinal[i,7] <-  basinsfinal[i,7] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #
}#
#
#equitypefive: High C1 High M2 C2>0 M1>0 (basically: C1 > C2, M2 > M1 but C2,M1>0 and C1 > M1, M2 > C2)#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twop
atch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$
q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"])){#
basinsfinal[i,8] <- basinsfinal[i,8] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
#equitypesix: High C2 High M1 C1>0 M2>0 (basically: C2 > C1, M1 > M2 but M2,C1>0 and C1 < M1, M2 < C2)#
if((twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twop
atch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$
q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"])){#
basinsfinal[i,9] <- basinsfinal[i,9] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100#
}#
#
#equitypeseven: high coral M > 0 both patches (basically: C1 > M1, C2 > M2, but M1,M2 > 0)#
if((twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == g
lvl & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"])){#
basinsfinal[i,10] <-  basinsfinal[i,10] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #
}#
#
#equitypeeight: high macroalgae C > 0 both patches (basically: M1 > C1, M2 > C2, but C1,C2 > 0)#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == g
lvl & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"])){#
basinsfinal[i,11] <-  basinsfinal[i,11] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #
}#
#
#equitypenine: C = M both patches#
if((twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] > 0) & (twopatch_ext_complete$M1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == twopatch_ext_complete$C1[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 ==
glvl & twopatch_ext_complete$stability == "stable_node"]) & (twopatch_ext_complete$M2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"] == twopatch_ext_complete$C2[twopatch_ext_complete$ID == j & twopatch_ext_complete$g == round(g_val,4) & twopatch_ext_complete$q_c == recruit & twopatch_ext_complete$q_m == recruit & twopatch_ext_complete$g2 == glvl & twopatch_ext_complete$stability == "stable_node"])){#
basinsfinal[i,12] <-  basinsfinal[i,12] + (basinsabr$Size[basinsabr$EquilibriumID == j]/210)*100 #
}#
} #end of if statement	#
#
basinsfinal[i,13] <- basinsfinal[i,4]+basinsfinal[i,5]+basinsfinal[i,6]+basinsfinal[i,7] + basinsfinal[i,8]+basinsfinal[i,9]+basinsfinal[i,10]+basinsfinal[i,11]+basinsfinal[i,12]#
#
if(i == stopp){#
save(basinsfinal, file = paste0("hg_basinsfinal_",stopp,".RData"))#
stopp = stopp + 1000#
}#
#
} #end of j loop#
basinsabr <- 0 #clear it, just in case#
} #end of i loop#
#
save(basinsfinal, file = "hg_basinsfinal_done_alllong.RData")
sum(basinsfinal[,13])
which(round(basinsfinal[,13],4) < 100)
length(which(round(basinsfinal[,13],4) < 100))
pdf("AllHeatMapsOrganizedbyEqui_heterograz_lowlabel.pdf")#
par(mfrow = c(4,3)) #per page in the pdf#
#
#equitypeone#
image.plot(t(matrix(basinsfinal[1:9900,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypetwo#
image.plot(t(matrix(basinsfinal[1:9900,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighM1M2,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypethree#
image.plot(t(matrix(basinsfinal[1:9900,6], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1M2,C2=M1=0,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,6], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,6], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypefour#
image.plot(t(matrix(basinsfinal[1:9900,7], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "High C2M1,C1=M2=0,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,7], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,7], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypefive#
image.plot(t(matrix(basinsfinal[1:9900,8], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "High C1M2,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,8], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,8], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypesix#
image.plot(t(matrix(basinsfinal[1:9900,9], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "High C2M1,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,9], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,9], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypeseven#
image.plot(t(matrix(basinsfinal[1:9900,10], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2,M>0,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,10], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,10], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypeeight#
image.plot(t(matrix(basinsfinal[1:9900,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "High M1M2,C>0,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypenine#
image.plot(t(matrix(basinsfinal[1:9900,12], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "M=C,low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,12], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,12], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
dev.off()#
#
#RAINBOW VERSION (low label, joined equi)#
#equitypeone: high coral zero macroalgae both patches, equitypetwo: high macroalgae zero coral both patches, equitypethree: High C1 High M2 C2=M1=0, equitypefour: High C2 High M1 C1=M2=0, equitypefive: High C1 High M2 C2>0 M1>0, equitypesix: High C2 High M1 C1>0 M2>0, equitypeseven: high coral M > 0 both patches, equitypeeight: high macroalgae C > 0 both patches, equitypenine: C = M both patches#
pdf("AllHeatMapsOrganizedbyEqui_heterograz_lowlabel_joinedequi.pdf")#
par(mfrow = c(4,3))#
#
#equitypeone#
image.plot(t(matrix(basinsfinal[1:9900,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2, low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypetwo#
image.plot(t(matrix(basinsfinal[1:9900,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "High M1M2, low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypethree + equitypefour#
image.plot(t(matrix(basinsfinal[1:9900,6]+basinsfinal[1:9900,7], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "Mismatch nonmixed, low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,6]+basinsfinal[9901:19800,7], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,6]+basinsfinal[19801:29700,7], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypefive + equitypesix#
image.plot(t(matrix(basinsfinal[1:9900,8]+basinsfinal[1:9900,9], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "Mismatch mixedlow grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,8]+basinsfinal[9901:19800,9], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,8]+basinsfinal[19801:29700,9], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypeeight#
image.plot(t(matrix(basinsfinal[1:9900,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "High M1M2, C non-zero, low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypeseven (high C1C2, M nonzero), equitypenine (M=C everywhere) never happen#
#
dev.off()#
#
#RAINBOW VERSION (low label, v joined equi)#
#equitypeone: high coral zero macroalgae both patches, equitypetwo: high macroalgae zero coral both patches, equitypethree: High C1 High M2 C2=M1=0, equitypefour: High C2 High M1 C1=M2=0, equitypefive: High C1 High M2 C2>0 M1>0, equitypesix: High C2 High M1 C1>0 M2>0, equitypeseven: high coral M > 0 both patches, equitypeeight: high macroalgae C > 0 both patches, equitypenine: C = M both patches#
pdf("AllHeatMapsOrganizedbyEqui_heterograz_lowlabel_vjoinedequi.pdf")#
par(mfrow = c(3,3))#
#
#equitypeone#
image.plot(t(matrix(basinsfinal[1:9900,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "HighC1C2, low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,4], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypetwo#
image.plot(t(matrix(basinsfinal[1:9900,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "High M1M2, low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,5], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypethree + equitypefour +5+6+8#
image.plot(t(matrix(basinsfinal[1:9900,6]+basinsfinal[1:9900,7] + basinsfinal[1:9900,8]+basinsfinal[1:9900,9] + basinsfinal[1:9900,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", ylab = "dispersal", main = "Mixed, low grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[9901:19800,6]+basinsfinal[9901:19800,7]+basinsfinal[9901:19800,8]+basinsfinal[9901:19800,9] + basinsfinal[9901:19800,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "medium grazing",zlim=c(0,100))#
image.plot(t(matrix(basinsfinal[19801:29700,6]+basinsfinal[19801:29700,7] + basinsfinal[19801:29700,8]+basinsfinal[19801:29700,9] + basinsfinal[19801:29700,11], nrow = 100, ncol = 99)), col = c("gray", tim.colors(300)), xlab = "grazing", yaxt="n", main = "high grazing",zlim=c(0,100))#
#
#equitypeseven (high C1C2, M nonzero), equitypenine (M=C everywhere) never happen#
#
dev.off()
load('~/Dropbox/University of Toronto/Research Related/R outputs/Two Patch Elmhirst extended/Heterogeneous_Grazing/afterdealingwith2856-2900problems/hg_basinsfinal_done_alllong.RData')
basinsfinal[2850:2860,]
reefdata <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")
head(reefdata)
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
reefdata <- NULL
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data
head(reefdata_old)
dim(reefdata_full)
reefdata <- reefdata_full[c(3:6,34,13:28)]
head(reefdata)
names(reefdata)
names(reefdata) <- ("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")
head(reefdata)
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(maps)#
#
plot.map<- function(database,center,...){#
    Obj <- map(database,...,plot=F)#
    coord <- cbind(Obj[[1]],Obj[[2]])#
#
    # split up the coordinates#
    id <- rle(!is.na(coord[,1]))#
    id <- matrix(c(1,cumsum(id$lengths)),ncol=2,byrow=T)#
    polygons <- apply(id,1,function(i){coord[i[1]:i[2],]})#
#
    # split up polygons that differ too much#
    polygons <- lapply(polygons,function(x){#
        x[,1] <- x[,1] + center#
        x[,1] <- ifelse(x[,1]>180,x[,1]-360,x[,1])#
        if(sum(diff(x[,1])>300,na.rm=T) >0){#
          id <- x[,1] < 0#
          x <- rbind(x[id,],c(NA,NA),x[!id,])#
       }#
       x#
    })#
    # reconstruct the object#
    polygons <- do.call(rbind,polygons)#
    Obj[[1]] <- polygons[,1]#
    Obj[[2]] <- polygons[,2]#
#
    map(Obj,...)#
}#
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#thresholding by 3.3% probability (see 'Comparing_Options' file, note: connmat_reduced@x turns the matrix into a vector)#
connmat_reduced@x[connmat_reduced@x <= 0.033] <- 0#
#check - okay it's actually fine#
which(connmat_reduced[which(connmat_reduced <= 0.033)] > 0)#
#
#method 2#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
connmat_reduced <- connmat_thresholder#
#check#
connmat_reduced[which(connmat_reduced <= 0.033)] #same weirdness (no actually it's fine)#
#
#load in the centroids, NOTE: NEED TO FIX THE LONGITUDE IN THESE ONES (>180 ones need to have -360 subtracted)#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/centroids.RData')#
#head(centroids) #
#
#reefdata is what needs to be replaced, load in new .csv file#
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
dim(reefdata_full)#
reefdata <- reefdata_full[c(3:6,34,13:28)]#
head(reefdata)#
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")#
#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)#
#remove the rows corresponding to the grid cells that have no reef SA#
centroids_reduced <- centroids[-id.noReef,]#
dim(centroids_reduced) #12292 #
#save(centroids_reduced, file = "centroids_reduced.RData")#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2#
#
#correct the longitude#
reefdata$Longitude[reefdata$Longitude > 180] <- reefdata$Longitude[reefdata$Longitude > 180] - 360#
centroids_reduced$Longitude[centroids_reduced$Longitude > 180] <- centroids_reduced$Longitude[centroids_reduced$Longitude > 180] - 360#
#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360
head(reefdata)
##Calculating where to stop the destruction#
#total SA: 12292*324km^2 = 3,982,608km#
#12292/434 = ~28#
#SA of BCU reefs (50 reefs)#
length(reefdata$BCU_ID[reefdata$BCU_ID > 0]) #3334, 3334*(18*18) = 1,080,216km^2#
#3334/434 = ~8#
#so if want to stop when the reef SA = 50 reefs SA, should stop at 20 iterations #
num_iter <- 20
head(reefdata_old[,c(2,3,4,5,12,13,27,28)])
head(reefdata_full[1,])
head(reefdata_full[,1])
head(reefdata_full[,c(3:6,34,13:28)])
#reefdata is what needs to be replaced, load in new .csv file#
#note: the scores from Hawthorne were in a different order than those from Marco but once they got spatially joined into 12292 cells, it's fine#
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
dim(reefdata_full)#
reefdata <- reefdata_full[,c(3:6,34,13:28)]#
head(reefdata)#
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")#
#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)#
#remove the rows corresponding to the grid cells that have no reef SA#
centroids_reduced <- centroids[-id.noReef,]#
dim(centroids_reduced) #12292 #
#save(centroids_reduced, file = "centroids_reduced.RData")#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2#
#
#correct the longitude#
reefdata$Longitude[reefdata$Longitude > 180] <- reefdata$Longitude[reefdata$Longitude > 180] - 360#
centroids_reduced$Longitude[centroids_reduced$Longitude > 180] <- centroids_reduced$Longitude[centroids_reduced$Longitude > 180] - 360#
#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360
##Calculating where to stop the destruction#
#total SA: 12292*324km^2 = 3,982,608km#
#12292/434 = ~28#
#SA of BCU reefs (50 reefs)#
length(reefdata$BCU_ID[reefdata$BCU_ID > 0]) #3334, 3334*(18*18) = 1,080,216km^2#
#3334/434 = ~8#
#so if want to stop when the reef SA = 50 reefs SA, should stop at 20 iterations #
num_iter <- 20
head(reefdata_old[,c(2,3,4,5,12,13,27,28)])
head(reefdata_old)
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)
head(reefdata_old[,c(5:6)])
head(reefdata_old[,c(12:13)])
head(reefdata_old[,c(27:28)])
head(reefdata)
dim(reefdata_old)
reefdata1 <- reefdata[,c(2,3,4,5,7,8,9,22)]
head(reefdata1)
#remove from lowest (worst) to highest (best) score, in batches of num_remove (434)#
#calculating the metrics as we go#
ord <- order(reefdata$score) #lowest to highest#
#ord <- order(reefdata$score, decreasing = TRUE) #highest to lowest#
fr <- so_st <- ss <- cl <- dg <- df <- list() #initialize blank lists, each iteration adding in a new dataframe to each list#
reefdata1 <- reefdata[,c(2,3,4,5,7,8,9,22)] #each time, just going to remove from the complete dataframe#
#i goes to 20 - won't get down to 0 reefs, but that's what we want#
num_remove <- 434 #remove 434 the first time, 434 the next run (total of 868 removed), etc#
for(i in 1 : num_iter) {#
    final_reef <- (i*num_remove)  #
    connmat_i <- connmat_reduced[-ord[1:final_reef],-ord[1:final_reef]]#
    df[[i]] <- reefdata1[-ord[1:final_reef],]#
    g <- graph.adjacency(as.matrix(connmat_i), weighted = TRUE)#
    cl[[i]] <- clusters(g,mode="weak") #number of clusters, size of each cluster, membership of each cluster#
    dg[[i]] <- degree(g) #getting node degree#
    so_st[[i]] <- ego_size(graph = g, order = 40, nodes = V(g), mode = "out")#
    fr[[i]] <- length(reefdata1$BCU_ID[reefdata1$BCU_ID > 0][-ord[1:final_reef]])#
}
#Plot how average source strength changes across removal 'time'#
nrf_remov <- avg_sost <- rep(NA,(num_iter+1))#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
avg_sost[1] <- mean(ego_size(graph = g_orig, order = 40, nodes = V(g_orig), mode = "out"))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    avg_sost[i] <- mean(so_st[[i-1]])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Source_strength_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = avg_sost, xlab = "% of reefs remaining", ylab = "Avg Source Strength", type = 'l', xlim = rev(range(nrf_remaining)),main = "3.3% screened", ylim =  c(0,100))#
dev.off()#
#
#Global Distribution of Source Strength across removal 'time'#
maxval <- range(ego_size(graph = g_orig, order = 40, nodes = V(g_orig), mode = "out"))[2]#
cols_source <- tim.colors(maxval+1)#
for(i in 1:num_iter){#
df[[i]]$sost_col <- cols_source[so_st[[i]]]#
png(file=paste0("GlobalSourceStrength_",round(nrf_remaining[i+1],2),"PercentReefsRemaining_b_last.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Global Distribution of Source Strength",round(nrf_remaining[i+1],2),"% Reefs Remaining"),lwd = 0.000002, col = "light grey")#
points(df[[i]]$Longitude,df[[i]]$Latitude,col=df[[i]]$sost_col,pch=20,cex=0.2)#
legend("topleft", c("Out-degree = 1", "Out-degree = 350", "Out-degree = 709"), col = c(cols_source[1],cols_source[350],cols_source[709]), pch = c(20,20,20))#
dev.off()#
#
png(file=paste0("GlobalSourceStrength_",round(nrf_remaining[i+1],2),"PercentReefsRemaining_b_last_small.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Global Distribution of Source Strength",round(nrf_remaining[i+1],2),"% Reefs Remaining"),lwd = 0.000002, col = "light grey")#
points(df[[i]]$Longitude,df[[i]]$Latitude,col=df[[i]]$sost_col,pch=15,cex=0.03)#
legend("topleft", c("Out-degree = 1", "Out-degree = 350", "Out-degree = 709"), col = c(cols_source[1],cols_source[350],cols_source[709]), pch = c(15,15,15))#
dev.off()#
}#
dev.off()#
#
#Plot how 50 reefs are lost across removal 'time'#
nrf_remov <- nfr <- rep(NA,(num_iter+1))#
nfr[1] <- length(reefdata$BCU_ID[reefdata$BCU_ID > 0])#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    nfr[i] <- length(df[[i-1]]$BCU_ID[df[[i-1]]$BCU_ID > 0])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Num_50r_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = nfr, xlab = "% of reefs remaining", ylab = "Number of 50 reefs", type = 'l', main = "3.3% screened", xlim = rev(range(nrf_remaining))) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
#Plot how number of clusters changes across removal 'time'#
nrf_remov <- nclo <- rep(NA,(num_iter+1))#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
nclo[1] <- clusters(g_orig, mode = "weak")$no#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    nclo[i] <- cl[[i-1]]$no#
}#
#nrf_remaining <- 12292 - nrf_remov#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Num_clusters_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = nclo, xlab = "% of reefs remaining", ylab = "Number of clusters", type = 'l', main = "3.3% screened", xlim = rev(range(nrf_remaining)), ylim = c(150,1450)) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#png(file="Num_clusters_b_last.png",width=12,height=10,units="cm",res=300)#
#plot(x = nrf_remaining,y = nclo, xlab = "Number of reefs remaining", ylab = "#Clusters", main = "Number of Clusters", xlim = rev(range(nrf_remaining)), pch = 20) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
#dev.off()#
#
#Plot how the size of the largest cluster changes across removal 'time'#
nrf_remov <- largest_cluster <- rep(NA,(num_iter+1))#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
largest_cluster[1] <- max(clusters(g_orig, mode = "weak")$csize)#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    largest_cluster[i] <- max(cl[[i-1]]$csize)#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
#plot(x = nrf_remaining,y = largest_cluster, xlab = "Number of reefs remaining", ylab = "Largest cluster", main = "Over 40km screened", xlim = rev(range(nrf_remaining)))#
png(file="Size_clusters_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = largest_cluster, xlab = "% of reefs remaining", ylab = "Size of Largest Cluster", main = "Size of Largest Cluster, 3.3% screened", xlim = rev(range(nrf_remaining)), type = 'l', ylim = c(0,6000)) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
#Plot how the average node degree changes across removal 'time'#
nrf_remov <- avg_degree <- rep(NA,(num_iter+1))#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
avg_degree[1] <- mean(degree(g_orig))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    avg_degree[i] <- mean(dg[[i-1]])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Node_degree_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = avg_degree, xlab = "% of reefs remaining", ylab = "Avg Node Degree", type = 'l', xlim = rev(range(nrf_remaining)),main = "3.3% screened", ylim = c(3,10))#
dev.off()
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(maps)#
#
plot.map<- function(database,center,...){#
    Obj <- map(database,...,plot=F)#
    coord <- cbind(Obj[[1]],Obj[[2]])#
#
    # split up the coordinates#
    id <- rle(!is.na(coord[,1]))#
    id <- matrix(c(1,cumsum(id$lengths)),ncol=2,byrow=T)#
    polygons <- apply(id,1,function(i){coord[i[1]:i[2],]})#
#
    # split up polygons that differ too much#
    polygons <- lapply(polygons,function(x){#
        x[,1] <- x[,1] + center#
        x[,1] <- ifelse(x[,1]>180,x[,1]-360,x[,1])#
        if(sum(diff(x[,1])>300,na.rm=T) >0){#
          id <- x[,1] < 0#
          x <- rbind(x[id,],c(NA,NA),x[!id,])#
       }#
       x#
    })#
    # reconstruct the object#
    polygons <- do.call(rbind,polygons)#
    Obj[[1]] <- polygons[,1]#
    Obj[[2]] <- polygons[,2]#
#
    map(Obj,...)#
}#
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#thresholding by 3.3% probability (see 'Comparing_Options' file, note: connmat_reduced@x turns the matrix into a vector)#
connmat_reduced@x[connmat_reduced@x <= 0.033] <- 0#
#check - okay it's actually fine#
which(connmat_reduced[which(connmat_reduced <= 0.033)] > 0)#
#
#method 2#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
connmat_reduced <- connmat_thresholder#
#check#
connmat_reduced[which(connmat_reduced <= 0.033)] #same weirdness (no actually it's fine)#
#
#load in the centroids, NOTE: NEED TO FIX THE LONGITUDE IN THESE ONES (>180 ones need to have -360 subtracted)#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/centroids.RData')#
#head(centroids) #
#
#reefdata is what needs to be replaced, load in new .csv file#
#note: the scores from Hawthorne were in a different order than those from Marco but once they got spatially joined into 12292 cells, it's fine#
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
dim(reefdata_full)#
reefdata <- reefdata_full[,c(3:6,34,13:28)]#
head(reefdata)#
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")#
#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)#
#remove the rows corresponding to the grid cells that have no reef SA#
centroids_reduced <- centroids[-id.noReef,]#
dim(centroids_reduced) #12292 #
#save(centroids_reduced, file = "centroids_reduced.RData")#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2#
#
#correct the longitude#
reefdata$Longitude[reefdata$Longitude > 180] <- reefdata$Longitude[reefdata$Longitude > 180] - 360#
centroids_reduced$Longitude[centroids_reduced$Longitude > 180] <- centroids_reduced$Longitude[centroids_reduced$Longitude > 180] - 360#
#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360#
##Calculating where to stop the destruction#
#total SA: 12292*324km^2 = 3,982,608km#
#12292/434 = ~28#
#SA of BCU reefs (50 reefs)#
length(reefdata$BCU_ID[reefdata$BCU_ID > 0]) #3334, 3334*(18*18) = 1,080,216km^2#
#3334/434 = ~8#
#so if want to stop when the reef SA = 50 reefs SA, should stop at 20 iterations #
num_iter <- 20#
#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#remove from lowest (worst) to highest (best) score, in batches of num_remove (434)#
#calculating the metrics as we go#
ord <- order(reefdata$score) #lowest to highest#
#ord <- order(reefdata$score, decreasing = TRUE) #highest to lowest#
fr <- so_st <- ss <- cl <- dg <- df <- list() #initialize blank lists, each iteration adding in a new dataframe to each list#
reefdata1 <- reefdata[,c(2,3,4,5,7,8,9,22)] #each time, just going to remove from the complete dataframe#
#i goes to 20 - won't get down to 0 reefs, but that's what we want#
num_remove <- 434 #remove 434 the first time, 434 the next run (total of 868 removed), etc#
for(i in 1 : num_iter) {#
    final_reef <- (i*num_remove)  #
    connmat_i <- connmat_reduced[-ord[1:final_reef],-ord[1:final_reef]]#
    df[[i]] <- reefdata1[-ord[1:final_reef],]#
    g <- graph.adjacency(as.matrix(connmat_i), weighted = TRUE)#
    cl[[i]] <- clusters(g,mode="weak") #number of clusters, size of each cluster, membership of each cluster#
    dg[[i]] <- degree(g) #getting node degree#
    so_st[[i]] <- ego_size(graph = g, order = 40, nodes = V(g), mode = "out")#
    fr[[i]] <- length(reefdata1$BCU_ID[reefdata1$BCU_ID > 0][-ord[1:final_reef]])#
}#
#Plot how average source strength changes across removal 'time'#
nrf_remov <- avg_sost <- rep(NA,(num_iter+1))#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
avg_sost[1] <- mean(ego_size(graph = g_orig, order = 40, nodes = V(g_orig), mode = "out"))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    avg_sost[i] <- mean(so_st[[i-1]])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Source_strength_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = avg_sost, xlab = "% of reefs remaining", ylab = "Avg Source Strength", type = 'l', xlim = rev(range(nrf_remaining)),main = "3.3% screened", ylim =  c(0,100))#
dev.off()#
#
#Global Distribution of Source Strength across removal 'time'#
maxval <- range(ego_size(graph = g_orig, order = 40, nodes = V(g_orig), mode = "out"))[2]#
cols_source <- tim.colors(maxval+1)#
for(i in 1:num_iter){#
df[[i]]$sost_col <- cols_source[so_st[[i]]]#
png(file=paste0("GlobalSourceStrength_",round(nrf_remaining[i+1],2),"PercentReefsRemaining_b_last.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Global Distribution of Source Strength",round(nrf_remaining[i+1],2),"% Reefs Remaining"),lwd = 0.000002, col = "light grey")#
points(df[[i]]$Longitude,df[[i]]$Latitude,col=df[[i]]$sost_col,pch=20,cex=0.2)#
legend("topleft", c("Out-degree = 1", "Out-degree = 350", "Out-degree = 709"), col = c(cols_source[1],cols_source[350],cols_source[709]), pch = c(20,20,20))#
dev.off()#
#
png(file=paste0("GlobalSourceStrength_",round(nrf_remaining[i+1],2),"PercentReefsRemaining_b_last_small.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Global Distribution of Source Strength",round(nrf_remaining[i+1],2),"% Reefs Remaining"),lwd = 0.000002, col = "light grey")#
points(df[[i]]$Longitude,df[[i]]$Latitude,col=df[[i]]$sost_col,pch=15,cex=0.03)#
legend("topleft", c("Out-degree = 1", "Out-degree = 350", "Out-degree = 709"), col = c(cols_source[1],cols_source[350],cols_source[709]), pch = c(15,15,15))#
dev.off()#
}#
dev.off()#
#
#Plot how 50 reefs are lost across removal 'time'#
nrf_remov <- nfr <- rep(NA,(num_iter+1))#
nfr[1] <- length(reefdata$BCU_ID[reefdata$BCU_ID > 0])#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    nfr[i] <- length(df[[i-1]]$BCU_ID[df[[i-1]]$BCU_ID > 0])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Num_50r_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = nfr, xlab = "% of reefs remaining", ylab = "Number of 50 reefs", type = 'l', main = "3.3% screened", xlim = rev(range(nrf_remaining))) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
#Plot how number of clusters changes across removal 'time'#
nrf_remov <- nclo <- rep(NA,(num_iter+1))#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
nclo[1] <- clusters(g_orig, mode = "weak")$no#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    nclo[i] <- cl[[i-1]]$no#
}#
#nrf_remaining <- 12292 - nrf_remov#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Num_clusters_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = nclo, xlab = "% of reefs remaining", ylab = "Number of clusters", type = 'l', main = "3.3% screened", xlim = rev(range(nrf_remaining)), ylim = c(150,1450)) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#png(file="Num_clusters_b_last.png",width=12,height=10,units="cm",res=300)#
#plot(x = nrf_remaining,y = nclo, xlab = "Number of reefs remaining", ylab = "#Clusters", main = "Number of Clusters", xlim = rev(range(nrf_remaining)), pch = 20) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
#dev.off()#
#
#Plot how the size of the largest cluster changes across removal 'time'#
nrf_remov <- largest_cluster <- rep(NA,(num_iter+1))#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
largest_cluster[1] <- max(clusters(g_orig, mode = "weak")$csize)#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    largest_cluster[i] <- max(cl[[i-1]]$csize)#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
#plot(x = nrf_remaining,y = largest_cluster, xlab = "Number of reefs remaining", ylab = "Largest cluster", main = "Over 40km screened", xlim = rev(range(nrf_remaining)))#
png(file="Size_clusters_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = largest_cluster, xlab = "% of reefs remaining", ylab = "Size of Largest Cluster", main = "Size of Largest Cluster, 3.3% screened", xlim = rev(range(nrf_remaining)), type = 'l', ylim = c(0,6000)) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
#Plot how the average node degree changes across removal 'time'#
nrf_remov <- avg_degree <- rep(NA,(num_iter+1))#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
avg_degree[1] <- mean(degree(g_orig))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    avg_degree[i] <- mean(dg[[i-1]])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Node_degree_b_last.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = avg_degree, xlab = "% of reefs remaining", ylab = "Avg Node Degree", type = 'l', xlim = rev(range(nrf_remaining)),main = "3.3% screened", ylim = c(3,10))#
dev.off()
#remove from lowest (worst) to highest (best) score, in batches of num_remove (434)#
#calculating the metrics as we go#
#ord <- order(reefdata$score) #lowest to highest#
ord <- order(reefdata$score, decreasing = TRUE) #highest to lowest#
fr <- so_st <- ss <- cl <- dg <- df <- list() #initialize blank lists, each iteration adding in a new dataframe to each list#
reefdata1 <- reefdata[,c(2,3,4,5,7,8,9,22)] #each time, just going to remove from the complete dataframe#
#i goes to 20 - won't get down to 0 reefs, but that's what we want#
num_remove <- 434 #remove 434 the first time, 434 the next run (total of 868 removed), etc#
for(i in 1 : num_iter) {#
    final_reef <- (i*num_remove)  #
    connmat_i <- connmat_reduced[-ord[1:final_reef],-ord[1:final_reef]]#
    df[[i]] <- reefdata1[-ord[1:final_reef],]#
    g <- graph.adjacency(as.matrix(connmat_i), weighted = TRUE)#
    cl[[i]] <- clusters(g,mode="weak") #number of clusters, size of each cluster, membership of each cluster#
    dg[[i]] <- degree(g) #getting node degree#
    so_st[[i]] <- ego_size(graph = g, order = 40, nodes = V(g), mode = "out")#
    fr[[i]] <- length(reefdata1$BCU_ID[reefdata1$BCU_ID > 0][-ord[1:final_reef]])#
}#
#Plot how average source strength changes across removal 'time'#
nrf_remov <- avg_sost <- rep(NA,(num_iter+1))#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
avg_sost[1] <- mean(ego_size(graph = g_orig, order = 40, nodes = V(g_orig), mode = "out"))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    avg_sost[i] <- mean(so_st[[i-1]])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Source_strength_b_first.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = avg_sost, xlab = "% of reefs remaining", ylab = "Avg Source Strength", type = 'l', xlim = rev(range(nrf_remaining)),main = "3.3% screened", ylim =  c(0,100))#
dev.off()#
#
#Global Distribution of Source Strength across removal 'time'#
maxval <- range(ego_size(graph = g_orig, order = 40, nodes = V(g_orig), mode = "out"))[2]#
cols_source <- tim.colors(maxval+1)#
for(i in 1:num_iter){#
df[[i]]$sost_col <- cols_source[so_st[[i]]]#
png(file=paste0("GlobalSourceStrength_",round(nrf_remaining[i+1],2),"PercentReefsRemaining_b_first.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Global Distribution of Source Strength",round(nrf_remaining[i+1],2),"% Reefs Remaining"),lwd = 0.000002, col = "light grey")#
points(df[[i]]$Longitude,df[[i]]$Latitude,col=df[[i]]$sost_col,pch=20,cex=0.2)#
legend("topleft", c("Out-degree = 1", "Out-degree = 350", "Out-degree = 709"), col = c(cols_source[1],cols_source[350],cols_source[709]), pch = c(20,20,20))#
dev.off()#
#
png(file=paste0("GlobalSourceStrength_",round(nrf_remaining[i+1],2),"PercentReefsRemaining_b_first_small.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Global Distribution of Source Strength",round(nrf_remaining[i+1],2),"% Reefs Remaining"),lwd = 0.000002, col = "light grey")#
points(df[[i]]$Longitude,df[[i]]$Latitude,col=df[[i]]$sost_col,pch=15,cex=0.03)#
legend("topleft", c("Out-degree = 1", "Out-degree = 350", "Out-degree = 709"), col = c(cols_source[1],cols_source[350],cols_source[709]), pch = c(15,15,15))#
dev.off()#
}#
dev.off()#
#
#Plot how 50 reefs are lost across removal 'time'#
nrf_remov <- nfr <- rep(NA,(num_iter+1))#
nfr[1] <- length(reefdata$BCU_ID[reefdata$BCU_ID > 0])#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    nfr[i] <- length(df[[i-1]]$BCU_ID[df[[i-1]]$BCU_ID > 0])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Num_50r_b_first.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = nfr, xlab = "% of reefs remaining", ylab = "Number of 50 reefs", type = 'l', main = "3.3% screened", xlim = rev(range(nrf_remaining))) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
#Plot how number of clusters changes across removal 'time'#
nrf_remov <- nclo <- rep(NA,(num_iter+1))#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
nclo[1] <- clusters(g_orig, mode = "weak")$no#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    nclo[i] <- cl[[i-1]]$no#
}#
#nrf_remaining <- 12292 - nrf_remov#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Num_clusters_b_first.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = nclo, xlab = "% of reefs remaining", ylab = "Number of clusters", type = 'l', main = "3.3% screened", xlim = rev(range(nrf_remaining)), ylim = c(150,1450)) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#png(file="Num_clusters_b_last.png",width=12,height=10,units="cm",res=300)#
#plot(x = nrf_remaining,y = nclo, xlab = "Number of reefs remaining", ylab = "#Clusters", main = "Number of Clusters", xlim = rev(range(nrf_remaining)), pch = 20) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
#dev.off()#
#
#Plot how the size of the largest cluster changes across removal 'time'#
nrf_remov <- largest_cluster <- rep(NA,(num_iter+1))#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
largest_cluster[1] <- max(clusters(g_orig, mode = "weak")$csize)#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    largest_cluster[i] <- max(cl[[i-1]]$csize)#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
#plot(x = nrf_remaining,y = largest_cluster, xlab = "Number of reefs remaining", ylab = "Largest cluster", main = "Over 40km screened", xlim = rev(range(nrf_remaining)))#
png(file="Size_clusters_b_first.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = largest_cluster, xlab = "% of reefs remaining", ylab = "Size of Largest Cluster", main = "Size of Largest Cluster, 3.3% screened", xlim = rev(range(nrf_remaining)), type = 'l', ylim = c(0,6000)) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
#Plot how the average node degree changes across removal 'time'#
nrf_remov <- avg_degree <- rep(NA,(num_iter+1))#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
avg_degree[1] <- mean(degree(g_orig))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
    avg_degree[i] <- mean(dg[[i-1]])#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Node_degree_b_first.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = avg_degree, xlab = "% of reefs remaining", ylab = "Avg Node Degree", type = 'l', xlim = rev(range(nrf_remaining)),main = "3.3% screened", ylim = c(3,10))#
dev.off()
# Map the clusters#
world <- readOGR(dsn = "~/Dropbox/University of Toronto/Research Related/Code from Marco 6.2018 mediterranean larval connectivity/worldcountryshapeetc", layer = "ne_110m_admin_0_countries")#
nrf_remov <-  rep(NA,(num_iter+1))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
#how many clusters are there, max#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
clusters(g_orig, mode = "weak")$no #805 ?no 604#
for(i in 1:num_iter){#
print(cl[[i]]$no) #827 -> ...#
}#
#
cols <- sample(tim.colors(clusters(g_orig, mode = "weak")$no)) #the original has the most clusters, useful to keep the colours of the clusters consistent (to the degree that this does that)#
#colouring some of them specific colours#
cols[166] <- "purple"#
cols[30] <- "pink"#
cols[1] <- "blue"#
cols[53] <- "green"#
cols[54] <- "red"#
cols[19] <- "black"
#map the clusters when no reefs removed#
reefdata1$cl.m <- clusters(g_orig, mode = "weak")$membership#
#cols <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]#
#cols <- sample(tim.colors(clusters(g_orig, mode = "weak")$no)) #defined above instead#
#reefdata1$cl.c <- cols[reefdata1$cl.m * 10]#
reefdata1$cl.c <- cols[reefdata1$cl.m]#
png(file=paste0(nrf_remaining[1],"%Reefs_Remaining_3.3screened.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
plot(world, main = paste(nrf_remaining[1],"%Reefs Remaining, 3.3%"))#
#points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.c,pch=20,cex=0.2)#
points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.m,pch=20,cex=0.2)#
dev.off()
#map the clusters when no reefs removed#
reefdata1$cl.m <- clusters(g_orig, mode = "weak")$membership#
#cols <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]#
#cols <- sample(tim.colors(clusters(g_orig, mode = "weak")$no)) #defined above instead#
#reefdata1$cl.c <- cols[reefdata1$cl.m * 10]#
reefdata1$cl.c <- cols[reefdata1$cl.m]#
png(file=paste0(nrf_remaining[1],"PercentReefs_Remaining_3.3screened.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
plot(world, main = paste(nrf_remaining[1],"%Reefs Remaining, 3.3%"))#
#points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.c,pch=20,cex=0.2)#
points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.m,pch=20,cex=0.2)#
dev.off()
png(file="AllReefs_Remaining_3.3screened.png",width=10,height=10,units="cm",res=1000, pointsize=4)#
plot(world, main = paste(nrf_remaining[1],"PercentReefs Remaining, 3.3%"), lwd = 0.000002, col = "light grey")#
#points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.c,pch=20,cex=0.2)#
points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.c,pch=20,cex=0.2)#
dev.off()#
#
png(file="All_Reefs_Remaining_3.3screened_small.png",width=20,height=20,units="cm",res=1500)#
plot(world, main = paste(nrf_remaining[1],"PercentReefs Remaining, 3.3%"), lwd = 0.000002, col = "light grey")#
points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.c,pch=15,cex=0.03)#
dev.off()#
#
plot(world, main = "6thbiggestcluster_AllReefs Remaining, 3.3%", lwd = 0.000002, col = "light grey")#
points(reefdata1$Longitude[reefdata1$cl.m == 1],reefdata1$Latitude[reefdata1$cl.m == 1],col=reefdata1$cl.c[reefdata1$cl.m == 1],pch=20,cex=0.2)
#PCentred maps #
for(i in 1:num_iter){#
df[[i]]$cl.m <- cl[[i]]$membership#
#cols <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]#
#cols <- sample(tim.colors(cl[[i]]$no)) #defined above instead#
#df[[i]]$cl.c <- cols[df[[i]]$cl.m * 10]#
df[[i]]$cl.c <- cols[df[[i]]$cl.m]#
png(file=paste0(nrf_remaining[i+1],"PercentReefs_Remaining_3.3screened.png"),width=10,height=10,units="cm",res=1000) #NEED TO RERUN bc got rid of pointsize since last saved#
plot.map("world", center=newcentre, col="gainsboro",bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(df[[i]]$Longitude_corrected,df[[i]]$Latitude,col=df[[i]]$cl.c,pch=20,cex=0.2)#
dev.off()#
}#
dev.off()
ord <- order(reefdata$score) #lowest to highest#
#ord <- order(reefdata$score, decreasing = TRUE) #highest to lowest#
fr <- so_st <- ss <- cl <- dg <- df <- list() #initialize blank lists, each iteration adding in a new dataframe to each list#
reefdata1 <- reefdata[,c(2,3,4,5,7,8,9,22)] #each time, just going to remove from the complete dataframe#
#i goes to 20 - won't get down to 0 reefs, but that's what we want#
num_remove <- 434 #remove 434 the first time, 434 the next run (total of 868 removed), etc#
for(i in 1 : num_iter) {#
    final_reef <- (i*num_remove)  #
    connmat_i <- connmat_reduced[-ord[1:final_reef],-ord[1:final_reef]]#
    df[[i]] <- reefdata1[-ord[1:final_reef],]#
    g <- graph.adjacency(as.matrix(connmat_i), weighted = TRUE)#
    cl[[i]] <- clusters(g,mode="weak") #number of clusters, size of each cluster, membership of each cluster#
    dg[[i]] <- degree(g) #getting node degree#
    so_st[[i]] <- ego_size(graph = g, order = 40, nodes = V(g), mode = "out")#
    fr[[i]] <- length(reefdata1$BCU_ID[reefdata1$BCU_ID > 0][-ord[1:final_reef]])#
}
world <- readOGR(dsn = "~/Dropbox/University of Toronto/Research Related/Code from Marco 6.2018 mediterranean larval connectivity/worldcountryshapeetc", layer = "ne_110m_admin_0_countries")#
nrf_remov <-  rep(NA,(num_iter+1))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
#how many clusters are there, max#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
clusters(g_orig, mode = "weak")$no #805 ?no 604#
for(i in 1:num_iter){#
print(cl[[i]]$no) #626 -> ...#
}
cols <- sample(tim.colors(clusters(g_orig, mode = "weak")$no)) #the original has the most clusters, useful to keep the colours of the clusters consistent (to the degree that this does that)#
#colouring some of them specific colours#
cols[166] <- "purple"#
cols[30] <- "pink"#
cols[1] <- "blue"#
cols[53] <- "green"#
cols[54] <- "red"#
cols[19] <- "black"
for(i in 1:num_iter){#
df[[i]]$cl.m <- cl[[i]]$membership#
#cols <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]#
#cols <- sample(tim.colors(cl[[i]]$no)) #defined above instead#
#df[[i]]$cl.c <- cols[df[[i]]$cl.m * 10]#
df[[i]]$cl.c <- cols[df[[i]]$cl.m]#
png(file=paste0(nrf_remaining[i+1],"PercentReefs_Remaining_3.3screened.png"),width=10,height=10,units="cm",res=1000) #NEED TO RERUN bc got rid of pointsize since last saved#
plot.map("world", center=newcentre, col="gainsboro",bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(df[[i]]$Longitude_corrected,df[[i]]$Latitude,col=df[[i]]$cl.c,pch=20,cex=0.2)#
dev.off()#
}#
dev.off()
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(ggplot2)#
library(maps)#
#
plot.map<- function(database,center,...){#
    Obj <- map(database,...,plot=F)#
    coord <- cbind(Obj[[1]],Obj[[2]])#
#
    # split up the coordinates#
    id <- rle(!is.na(coord[,1]))#
    id <- matrix(c(1,cumsum(id$lengths)),ncol=2,byrow=T)#
    polygons <- apply(id,1,function(i){coord[i[1]:i[2],]})#
#
    # split up polygons that differ too much#
    polygons <- lapply(polygons,function(x){#
        x[,1] <- x[,1] + center#
        x[,1] <- ifelse(x[,1]>180,x[,1]-360,x[,1])#
        if(sum(diff(x[,1])>300,na.rm=T) >0){#
          id <- x[,1] < 0#
          x <- rbind(x[id,],c(NA,NA),x[!id,])#
       }#
       x#
    })#
    # reconstruct the object#
    polygons <- do.call(rbind,polygons)#
    Obj[[1]] <- polygons[,1]#
    Obj[[2]] <- polygons[,2]#
#
    map(Obj,...)#
}#
####3.3% Removal Scenario#####
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#thresholding by 3.3% probability (see 'Comparing_Options' file, note: connmat_reduced@x turns the matrix into a vector)#
connmat_reduced@x[connmat_reduced@x <= 0.033] <- 0#
#check - okay it's actually fine#
which(connmat_reduced[which(connmat_reduced <= 0.033)] > 0)#
#
#method 2#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
#
#load in the centroids, NOTE: NEED TO FIX THE LONGITUDE IN THESE ONES (>180 ones need to have -360 subtracted)#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/centroids.RData')#
#head(centroids) #
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
dim(reefdata_full)#
reefdata <- reefdata_full[,c(3:6,34,13:28)]#
head(reefdata)#
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")#
#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)#
#
#remove the rows corresponding to the grid cells that have no reef SA#
centroids_reduced <- centroids[-id.noReef,]#
#dim(centroids_reduced) #12292 #
#save(centroids_reduced, file = "centroids_reduced.RData")#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2#
#
#correct the longitude#
reefdata$Longitude[reefdata$Longitude > 180] <- reefdata$Longitude[reefdata$Longitude > 180] - 360#
centroids_reduced$Longitude[centroids_reduced$Longitude > 180] <- centroids_reduced$Longitude[centroids_reduced$Longitude > 180] - 360#
#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360#
##Calculating where to stop the destruction#
#total SA: 12292*324km^2 = 3,982,608km#
#12292/434 = ~28#
#SA of BCU reefs (50 reefs)#
#length(reefdata$BCU_ID[reefdata$BCU_ID > 0]) #3334, 3334*(18*18) = 1,080,216km^2#
#3334/434 = ~8#
#so if want to stop when the reef SA = 50 reefs SA, should stop at 20 iterations #
num_iter <- 20#
set.seed(2)#
#remove from lowest (worst) to highest (best) score, in batches of num_remove (434)#
#calculating the metrics as we go#
#ord <- order(reefdata$score) #lowest to highest#
random_iter <- 100#
final_iterator <- 0 #IDEA: just keep adding to the original things and then take the mean and std. dev. of each set (1, 20+1, 40+1 representing one step)#
fr <- so_st <- cl <- dg <- df <- list() #initialize blank lists, each iteration adding in a new dataframe to each list#
reefdata1 <- reefdata[,c(2,3,4,5,7,8,9,22)] #each time, just going to remove from the complete dataframe#
for(j in 1:random_iter){#
print(paste("j = ", j))#
ord <- sample(seq(1,length(reefdata$score),by=1)) #highest to lowest#
#i goes to 20 - won't get down to 0 reefs, but that's what we want#
num_remove <- 434 #remove 434 the first time, 434 the next run (total of 868 removed), etc#
print(paste("i = ", i))#
for(i in (final_iterator + 1) : (num_iter+final_iterator)) {#
	print(paste("i = ",i, "final_i =", final_iterator))#
    final_reef <- ((i-final_iterator)*num_remove)  #
    connmat_i <- connmat_reduced[-ord[1:final_reef],-ord[1:final_reef]]#
    df[[i]] <- reefdata1[-ord[1:final_reef],]#
    g <- graph.adjacency(as.matrix(connmat_i), weighted = TRUE)#
    cl[[i]] <- clusters(g,mode="weak") #number of clusters, size of each cluster, membership of each cluster#
    dg[[i]] <- degree(g) #getting node degree#
    so_st[[i]] <- ego_size(graph = g, order = 40, nodes = V(g), mode = "out")#
    fr[[i]] <- length(reefdata1$BCU_ID[reefdata1$BCU_ID > 0][-ord[1:final_reef]])#
    if(i == num_iter+final_iterator){#
    	final_iterator <- num_iter+final_iterator#
    	i = 0#
    }#
}#
}#
save(fr,so_st,cl,dg,df, file = "RandomScenario_3.3_newscores_alldata.RData")
#Plot how average source strength changes across removal 'time'#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
nrf_remov <- sd_sost <- m_sost <- s_sost <- rep(NA,(num_iter+1))#
m_sost[1] <- mean(ego_size(graph = g_orig, order = 40, nodes = V(g_orig), mode = "out"))#
nrf_remov[1] <- 0#
for(i in 2:(num_iter+1)){#
nrf_remov[i] <- ((i-1)*num_remove)#
m_sost[i] <- 0#
for(j in 1:random_iter){ #calculate the mean#
	m_sost[i] <- m_sost[i] + (mean(so_st[[((i-1)+(num_iter*(j-1)))]])/random_iter)#
}#
s_sost[i] <- 0#
for(j in 1:random_iter){ #calculate  the standard deviation, first calc summation((x_i - x_bar)^2)#
	s_sost[i] <- s_sost[i] + ((mean(so_st[[((i-1)+(num_iter*(j-1)))]]) - m_sost[i])^2)#
}#
#then calc sqrt(summation/(n-1))#
sd_sost[i] <- sqrt(s_sost[i]/(random_iter-1))#
}#
#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Source_strength_random.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_sost, pch = 20, xlab = "% of reefs remaining", ylab = "Source Strength", main = "3.3% screened", xlim = rev(range(nrf_remaining))) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
sost <- list()#
for(i in 1:random_iter){#
sost[[i]] <- rep(NA,(num_iter+1))#
sost[[i]][1] <- mean(ego_size(graph = g_orig, order = 40, nodes = V(g_orig), mode = "out"))#
for(j in 2 : (num_iter+1)) {#
    sost[[i]][j] <-mean(so_st[[((j-1)+(num_iter*(i-1)))]])#
}#
}#
#
png(file="Source_strength_random_lines.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_sost, pch = 20, xlab = "% of reefs remaining", ylab = "Source strength", main = "3.3% screened", xlim = rev(range(nrf_remaining)), type = "n", ylim = c(0,100))#
for(i in 1:random_iter){#
	lines(x = nrf_remaining,y = sost[[i]],col = alpha("blue", 0.2), xlim = rev(range(nrf_remaining)))#
}#
points(x = nrf_remaining, y = m_sost, xlim = rev(range(nrf_remaining)), pch = 20)#
dev.off()#
#
raw_string <- rep(NA,random_iter)#
for(i in 1:random_iter){#
	raw_string[i] <- paste0("raw",i)#
}#
plotdata <- data.frame(x= nrf_remaining, y = m_sost, lower = m_sost - sd_sost, upper =  m_sost + sd_sost)#
#the two lines below work but are not needed#
#plotdata <- data.frame(x= nrf_remaining, y = m_nfr, lower = m_nfr - sd_nfr, upper =  m_nfr + sd_nfr, raw = nfr)#
#names(plotdata)[5:(random_iter+4)] <- as.character(raw_string)#
#
png(file="Source_strength_random_eb.png",width=12,height=10,units="cm",res=300)#
ggplot(plotdata)+#
geom_point(aes(y=y,x=x),pch=20)+#
#geom_line(aes(y=plotdata[,5],x=x),color="blue",alpha=0.2)+#
geom_ribbon(aes(ymin=lower,ymax=upper,x=x), alpha = 0.3)+#
scale_x_reverse(name = "% of reefs remaining")+#
ylab("Source Strength")+#
ggtitle("3.3% screened")+#
theme_bw(base_size = 18)+ #gets rid of grey background#
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) #removes grid lines#
#
dev.off()#
#
#TO DO, MAYBE: ^ can make maps of this by taking the average for a particular node at the different time points across replicates? not sure how informative that would be though#
#
#Plot how 50 reefs are lost across removal 'time'#
nrf_remov <- sd_nfr <- m_nfr <- s_nfr <- rep(NA,(num_iter+1))#
m_nfr[1] <- length(reefdata$BCU_ID[reefdata$BCU_ID > 0])#
nrf_remov[1] <- 0#
for(i in 2:(num_iter+1)){#
nrf_remov[i] <- ((i-1)*num_remove)#
m_nfr[i] <- 0#
for(j in 1:random_iter){ #calculate the mean#
	m_nfr[i] <- m_nfr[i] + (length(df[[((i-1)+(num_iter*(j-1)))]]$BCU_ID[df[[((i-1)+(num_iter*(j-1)))]]$BCU_ID > 0]))/random_iter#
}#
s_nfr[i] <- 0#
for(j in 1:random_iter){ #calculate  the standard deviation, first calc summation((x_i - x_bar)^2)#
	s_nfr[i] <- s_nfr[i] + ((length(df[[((i-1)+(num_iter*(j-1)))]]$BCU_ID[df[[((i-1)+(num_iter*(j-1)))]]$BCU_ID > 0]) - m_nfr[i])^2)#
}#
#then calc sqrt(summation/(n-1))#
sd_nfr[i] <- sqrt(s_nfr[i]/(random_iter-1))#
}#
#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Num_50r_random.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_nfr, pch = 20, xlab = "% of reefs remaining", ylab = "Number of 50 reefs", main = "3.3% screened", xlim = rev(range(nrf_remaining))) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
nfr <- list()#
for(i in 1:random_iter){#
nfr[[i]] <- rep(NA,(num_iter+1))#
nfr[[i]][1] <- length(reefdata$BCU_ID[reefdata$BCU_ID > 0])#
for(j in 2 : (num_iter+1)) {#
    nfr[[i]][j] <- length(df[[((j-1)+(num_iter*(i-1)))]]$BCU_ID[df[[((j-1)+(num_iter*(i-1)))]]$BCU_ID > 0])#
}#
}#
#
png(file="Num_50r_random_lines.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_nfr, pch = 20, xlab = "% of reefs remaining", ylab = "Number of 50 reefs", main = "3.3% screened", xlim = rev(range(nrf_remaining)), type = "n")#
for(i in 1:random_iter){#
	lines(x = nrf_remaining,y = nfr[[i]],col = alpha("blue", 0.2), xlim = rev(range(nrf_remaining)))#
}#
points(x = nrf_remaining, y = m_nfr, xlim = rev(range(nrf_remaining)), pch = 20)#
dev.off()#
#
raw_string <- rep(NA,random_iter)#
for(i in 1:random_iter){#
	raw_string[i] <- paste0("raw",i)#
}#
plotdata <- data.frame(x= nrf_remaining, y = m_nfr, lower = m_nfr - sd_nfr, upper =  m_nfr + sd_nfr)#
#the two lines below work but are not needed#
#plotdata <- data.frame(x= nrf_remaining, y = m_nfr, lower = m_nfr - sd_nfr, upper =  m_nfr + sd_nfr, raw = nfr)#
#names(plotdata)[5:(random_iter+4)] <- as.character(raw_string)#
#
png(file="Num_50r_random_eb.png",width=12,height=10,units="cm",res=300)#
ggplot(plotdata)+#
geom_point(aes(y=y,x=x),pch=20)+#
#geom_line(aes(y=plotdata[,5],x=x),color="blue",alpha=0.2)+#
geom_ribbon(aes(ymin=lower,ymax=upper,x=x), alpha = 0.3)+#
scale_x_reverse(name = "% of reefs remaining")+#
ylab("Number of 50 reefs")+#
ggtitle("3.3% screened")+#
theme_bw(base_size = 18)+ #gets rid of grey background#
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) #removes grid lines#
#
dev.off()#
#
#Plot how number of clusters changes across removal 'time'#
nrf_remov <- m_nclo <- sd_nclo <- s_nclo <- rep(NA,(num_iter+1))#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
m_nclo[1] <- clusters(g_orig, mode = "weak")$no#
nrf_remov[1] <- 0#
for(i in 2:(num_iter+1)){#
nrf_remov[i] <- ((i-1)*num_remove)#
m_nclo[i] <- 0#
for(j in 1:random_iter){ #calculate the mean#
	m_nclo[i] <- m_nclo[i] + (cl[[((i-1)+(num_iter*(j-1)))]]$no)/random_iter#
}#
s_nclo[i] <- 0#
for(j in 1:random_iter){ #calculate  the standard deviation, first calc summation((x_i - x_bar)^2)#
	s_nclo[i] <- s_nclo[i] + (((cl[[((i-1)+(num_iter*(j-1)))]]$no) - m_nclo[i])^2)#
}#
#then calc sqrt(summation/(n-1))#
sd_nclo[i] <- sqrt(s_nclo[i]/(random_iter-1))#
}#
#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Num_clusters_random.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_nclo, pch = 20, xlab = "% of reefs remaining", ylab = "Number of clusters", main = "3.3% screened", xlim = rev(range(nrf_remaining))) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#png(file="Num_clusters_b_last.png",width=12,height=10,units="cm",res=300)#
#plot(x = nrf_remaining,y = nclo, xlab = "Number of reefs remaining", ylab = "#Clusters", main = "Number of Clusters", xlim = rev(range(nrf_remaining)), pch = 20) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
#dev.off()#
#
nclo <- list()#
for(i in 1:random_iter){#
nclo[[i]] <- rep(NA,(num_iter+1))#
nclo[[i]][1] <- clusters(g_orig, mode = "weak")$no#
for(j in 2 : (num_iter+1)) {#
    nclo[[i]][j] <- cl[[((j-1)+(num_iter*(i-1)))]]$no#
}#
}#
#
png(file="Num_clusters_random_lines.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_nclo, pch = 20, xlab = "% of reefs remaining", ylab = "Number of clusters", main = "3.3% screened", xlim = rev(range(nrf_remaining)), type = "n", ylim = c(150,1450))#
for(i in 1:random_iter){#
	lines(x = nrf_remaining,y = nclo[[i]],col = alpha("blue", 0.2), xlim = rev(range(nrf_remaining)))#
}#
points(x = nrf_remaining, y = m_nclo, xlim = rev(range(nrf_remaining)), pch = 20)#
dev.off()#
#
plotdata <- data.frame(x= nrf_remaining, y = m_nclo, lower = m_nclo - sd_nclo, upper =  m_nclo + sd_nclo)#
png(file="Num_clusters_random_eb.png",width=12,height=10,units="cm",res=300)#
ggplot(plotdata)+#
geom_point(aes(y=y,x=x),pch=20)+#
geom_ribbon(aes(ymin=lower,ymax=upper,x=x), alpha = 0.3)+#
scale_x_reverse(name = "% of reefs remaining")+#
ylab("Number of clusters")+#
ggtitle("3.3% screened")+#
theme_bw(base_size = 18)+ #gets rid of grey background#
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) #removes grid lines#
dev.off()#
#
#Plot how the size of the largest cluster changes across removal 'time'#
nrf_remov <- s_largest_cluster <- m_largest_cluster <- sd_largest_cluster <- rep(NA,(num_iter+1))#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
m_largest_cluster[1] <- max(clusters(g_orig, mode = "weak")$csize)#
nrf_remov[1] <- 0#
for(i in 2:(num_iter+1)){#
nrf_remov[i] <- ((i-1)*num_remove)#
m_largest_cluster[i] <- 0#
for(j in 1:random_iter){ #calculate the mean#
	m_largest_cluster[i] <- m_largest_cluster[i] + (max(cl[[((i-1)+(num_iter*(j-1)))]]$csize))/random_iter#
}#
s_largest_cluster[i] <- 0#
for(j in 1:random_iter){ #calculate  the standard deviation, first calc summation((x_i - x_bar)^2)#
	s_largest_cluster[i] <- s_largest_cluster[i] + (((max(cl[[((i-1)+(num_iter*(j-1)))]]$csize)) - m_largest_cluster[i])^2)#
}#
#then calc sqrt(summation/(n-1))#
sd_largest_cluster[i] <- sqrt(s_largest_cluster[i]/(random_iter-1))#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
#plot(x = nrf_remaining,y = largest_cluster, xlab = "Number of reefs remaining", ylab = "Largest cluster", main = "Over 40km screened", xlim = rev(range(nrf_remaining)))#
png(file="Size_clusters_random.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_largest_cluster, xlab = "% of reefs remaining", ylab = "Size of Largest Cluster", main = "Size of Largest Cluster, 3.3% screened", xlim = rev(range(nrf_remaining)), pch = 20) #had to do this weird xlim thing to get the x-axis to go from largest -> smallest#
dev.off()#
#
largest_cluster <- list()#
for(i in 1:random_iter){#
largest_cluster[[i]] <- rep(NA,(num_iter+1))#
largest_cluster[[i]][1] <- max(clusters(g_orig, mode = "weak")$csize)#
for(j in 2 : (num_iter+1)) {#
    largest_cluster[[i]][j] <- (max(cl[[((j-1)+(num_iter*(i-1)))]]$csize))#
}#
}#
#
png(file="Size_clusters_random_lines.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_largest_cluster, pch = 20, xlab = "% of reefs remaining", ylab = "Size of Largest Cluster", main = "3.3% screened", xlim = rev(range(nrf_remaining)), type = "n", ylim = c(0,6000))#
for(i in 1:random_iter){#
	lines(x = nrf_remaining,y = largest_cluster[[i]],col = alpha("blue", 0.2), xlim = rev(range(nrf_remaining)))#
}#
points(x = nrf_remaining, y = m_largest_cluster, xlim = rev(range(nrf_remaining)), pch = 20)#
dev.off()#
#
plotdata <- data.frame(x= nrf_remaining, y = m_largest_cluster, lower = m_largest_cluster - sd_largest_cluster, upper =  m_largest_cluster + sd_largest_cluster)#
png(file="Size_clusters_random_eb.png",width=12,height=10,units="cm",res=300)#
ggplot(plotdata)+#
geom_point(aes(y=y,x=x),pch=20)+#
geom_ribbon(aes(ymin=lower,ymax=upper,x=x), alpha = 0.3)+#
scale_x_reverse(name = "% of reefs remaining")+#
ylab("Cluster Size")+#
ggtitle("3.3% screened")+#
theme_bw(base_size = 18)+ #gets rid of grey background#
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) #removes grid lines#
dev.off()#
#
#Plot how the average node degree changes across removal 'time'#
nrf_remov <- s_avg_degree <- sd_avg_degree <- m_avg_degree <- rep(NA,(num_iter+1))#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
m_avg_degree[1] <- mean(degree(g_orig))#
nrf_remov[1] <- 0#
for(i in 2:(num_iter+1)){#
nrf_remov[i] <- ((i-1)*num_remove)#
m_avg_degree[i] <- 0#
for(j in 1:random_iter){ #calculate the mean#
	m_avg_degree[i] <- m_avg_degree[i] + (mean(dg[[((i-1)+(num_iter*(j-1)))]]))/random_iter#
}#
s_avg_degree[i] <- 0#
for(j in 1:random_iter){ #calculate  the standard deviation, first calc summation((x_i - x_bar)^2)#
	s_avg_degree[i] <- s_avg_degree[i] + (((mean(dg[[((i-1)+(num_iter*(j-1)))]])) - m_avg_degree[i])^2)#
}#
#then calc sqrt(summation/(n-1))#
sd_avg_degree[i] <- sqrt(s_avg_degree[i]/(random_iter-1))#
}#
#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
png(file="Node_degree_random.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,pch = 20, y = m_avg_degree, xlab = "% of reefs remaining", ylab = "Avg Node Degree", xlim = rev(range(nrf_remaining)),main = "3.3% screened")#
dev.off()#
#
avg_degree <- list()#
for(i in 1:random_iter){#
avg_degree[[i]] <- rep(NA,(num_iter+1))#
avg_degree[[i]][1] <- mean(degree(g_orig))#
for(j in 2 : (num_iter+1)) {#
    avg_degree[[i]][j] <- (mean(dg[[((j-1)+(num_iter*(i-1)))]]))#
}#
}#
#
png(file="Node_degree_random_lines.png",width=12,height=10,units="cm",res=300)#
plot(x = nrf_remaining,y = m_avg_degree, pch = 20, xlab = "% of reefs remaining", ylab = "Avg Node Degree", main = "3.3% screened", xlim = rev(range(nrf_remaining)), type = "n", ylim = c(3,9))#
for(i in 1:random_iter){#
	lines(x = nrf_remaining,y = avg_degree[[i]],col = alpha("blue", 0.2), xlim = rev(range(nrf_remaining)))#
}#
points(x = nrf_remaining, y = m_avg_degree, xlim = rev(range(nrf_remaining)), pch = 20)#
dev.off()#
#
plotdata <- data.frame(x= nrf_remaining, y = m_avg_degree, lower = m_avg_degree - sd_avg_degree, upper =  m_avg_degree + sd_avg_degree)#
png(file="Node_degree_random_eb.png",width=12,height=10,units="cm",res=300)#
ggplot(plotdata)+#
geom_point(aes(y=y,x=x),pch=20)+#
geom_ribbon(aes(ymin=lower,ymax=upper,x=x), alpha = 0.3)+#
scale_x_reverse(name = "% of reefs remaining")+#
ylab("Avg Node Degree")+#
ggtitle("3.3% screened")+#
theme_bw(base_size = 18)+ #gets rid of grey background#
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) #removes grid lines#
dev.off()#
# Map the clusters#
world <- readOGR(dsn = "~/Dropbox/University of Toronto/Research Related/Code from Marco 6.2018 mediterranean larval connectivity/worldcountryshapeetc", layer = "ne_110m_admin_0_countries")#
nrf_remov <-  rep(NA,(num_iter+1))#
nrf_remov[1] <- 0#
for(i in 2 : (num_iter+1)) {#
    nrf_remov[i] <- ((i-1)*num_remove)#
}#
nrf_remaining <- (12292 - nrf_remov)/12292 * 100#
#how many clusters are there, max#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
clusters(g_orig, mode = "weak")$no #805#
#for(i in 1:num_iter){#
#print(cl[[i]]$no) #827 -> ...#
#}#
#
cols <- sample(tim.colors(clusters(g_orig, mode = "weak")$no)) #the original has the most clusters, useful to keep the colours of the clusters consistent (to the degree that this does that)#
#
#map the clusters when no reefs removed#
reefdata1$cl.m <- clusters(g_orig, mode = "weak")$membership#
#cols <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]#
#cols <- sample(tim.colors(clusters(g_orig, mode = "weak")$no)) #defined above instead#
#reefdata1$cl.c <- cols[reefdata1$cl.m * 10]#
reefdata1$cl.c <- cols[reefdata1$cl.m]#
png(file=paste0(nrf_remaining[1],"%Reefs_Remaining_3.3screened.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
plot(world, main = paste(nrf_remaining[1],"%Reefs Remaining, 3.3%"))#
#points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.c,pch=20,cex=0.2)#
points(reefdata1$Longitude,reefdata1$Latitude,col=reefdata1$cl.m,pch=20,cex=0.2)#
dev.off()#
dev.off()#
#
#add a column to the dataframe IDing which grid cells are in which clusters + then assigning colours (now w/n forloop)#
cols <- sample(tim.colors(clusters(g_orig, mode = "weak")$no))#
#plot the last iteration of the first set#
df[[num_iter]]$cl.m <- cl[[num_iter]]$membership#
df[[num_iter]]$cl.c <- cols[df[[num_iter]]$cl.m]#
#
df[[num_iter]]$Longitude_corrected <- df[[num_iter]]$Longitude#
df[[num_iter]]$Longitude_corrected[df[[num_iter]]$Longitude > 0 & df[[num_iter]]$Longitude  <  180] <- df[[num_iter]]$Longitude_corrected[df[[num_iter]]$Longitude > 0 & df[[num_iter]]$Longitude  <  180] - newcentre#
#
df[[num_iter]]$Longitude_corrected[df[[num_iter]]$Longitude < 0 & df[[num_iter]]$Longitude  >  -180] <- df[[num_iter]]$Longitude_corrected[df[[num_iter]]$Longitude < 0 & df[[num_iter]]$Longitude  >  -180] + newcentre#
#
png(file=paste0("Laststeprandom_Remaining_3.3screened.png"),width=10,height=10,units="cm",res=1000)#
plot.map("world", center=newcentre, col="gainsboro",bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(df[[num_iter]]$Longitude_corrected,df[[num_iter]]$Latitude,col=df[[num_iter]]$cl.c,pch=20,cex=0.2)#
dev.off()
head(reefdata_old[,c(2,3,4)])
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(colorRamps)#
library(maps)#
#
plot.map<- function(database,center,...){#
    Obj <- map(database,...,plot=F)#
    coord <- cbind(Obj[[1]],Obj[[2]])#
#
    # split up the coordinates#
    id <- rle(!is.na(coord[,1]))#
    id <- matrix(c(1,cumsum(id$lengths)),ncol=2,byrow=T)#
    polygons <- apply(id,1,function(i){coord[i[1]:i[2],]})#
#
    # split up polygons that differ too much#
    polygons <- lapply(polygons,function(x){#
        x[,1] <- x[,1] + center#
        x[,1] <- ifelse(x[,1]>180,x[,1]-360,x[,1])#
        if(sum(diff(x[,1])>300,na.rm=T) >0){#
          id <- x[,1] < 0#
          x <- rbind(x[id,],c(NA,NA),x[!id,])#
       }#
       x#
    })#
    # reconstruct the object#
    polygons <- do.call(rbind,polygons)#
    Obj[[1]] <- polygons[,1]#
    Obj[[2]] <- polygons[,2]#
#
    map(Obj,...)#
}
###REALIZED CONNECTIVITY####
#load in the shape file with all of the data#
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
dim(reefdata_full)#
reefdata <- reefdata_full[,c(3:6,34,13:28)]#
head(reefdata)#
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")#
#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)#
#
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
connmat_reduced <- connmat_thresholder#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2#
#
#correct the longitude#
reefdata$Longitude[reefdata$Longitude > 180] <- reefdata$Longitude[reefdata$Longitude > 180] - 360#
#
#for plotting pacific centred maps#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
#range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360#
world <- readOGR(dsn = "~/Dropbox/University of Toronto/Research Related/Code from Marco 6.2018 mediterranean larval connectivity/worldcountryshapeetc", layer = "ne_110m_admin_0_countries")#
#
#note: plateaupoint_cr = 26, plateaupoint_50r = 23, plateaupoint_pr = 23 so final plateaupoint = 23#
ultimateplateau <- 26#
reefdata2 <- reefdata[,c(2,3,4)]#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
#
#POSSIBLE THING TO DO: Cluster size of rebuilt clusters? like, size of the clusters as they exist at the end...not the amount of each of the former clusters that has been rebuilt but the size of the clusters as they are (i think the percentage rebuilt might be more informative? idk)#
#
#CHANGE TO TIM.COLOURS?#
#
#RESEEDING FROM 50 REEFS#
#Start with just the 50 reefs#
numsteps <-50
id.50reefs <- which(!is.na(reefdata$BCU_Name)) #this IDs the rows with 50 reefs#
length(id.50reefs) #3334#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = numsteps+1) #10 time steps#
abundance_mat[,1][id.50reefs] <- 100 #time step 0: assign all the 50 reefs to an abundance of 100#
#
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#
stop <- "no"#
#Plot the number that were re-seeded over time#
numreseeded_50r <- rep(NA,(numsteps+1))#
numreseeded_50r[1] <- 0#
for(i in 2:(numsteps + 1)){#
#line below could be simplified to just be length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[id.50reefs,i]) but whatever, same for all of the other scenarios#
numreseeded_50r[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[id.50reefs,i][abundance_mat[id.50reefs,i]>0])	#
if((numreseeded_50r[i] <= numreseeded_50r[i-1]) & stop == "no"){ #added the 'or' condition bc of some of the other cases needing it#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_50r <- plateaupoint#
png(paste0("Realized_CU_50R_Reseed_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=numreseeded_50r,main="Realized 50 Reefs Reseeded over Time",xlab = "Time Step", ylab = "# of Reseeded Reefs")#
dev.off()#
#
#starterreefs + first set seeded - colour the starterreefs green, the rest colour red#
#
#LOTS of plots for 50 steps...#
#for(i in 2:101){#
#id.abund <- which(abundance_mat[,i] > 0)#
#
#png(paste0("Realized_CU_50R_Reseed_TS",i-1,"_GR.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
#plot(world, main = paste("50 Reefs +",i-1,"Time Step"))#
#points(reefdata$Longitude,reefdata$Latitude,col=alpha("grey",0.2),pch=20,cex=0.2)#
#points(reefdata$Longitude[id.abund],reefdata$Latitude[id.abund],col="red",pch=20,cex=0.2) #
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2)#
#dev.off()#
#}#
#dev.off()#
#
id.abund <- list()#
for(i in 2:(numsteps+1)){#
id.abund[[i]] <- which((abundance_mat[,i] > 0) & (abundance_mat[,(i-1)] == 0))#
id.abund[[i]] <- id.abund[[i]][-id.50reefs]#
}#
#heatcols <- diverge_hcl(10)#
#heatcols <- heat_hcl(12,h=c(0,-100), l = c(75,40), c = c(40,80), power = 1)#
#heatcols <- heat_hcl(12,h=c(0,-100),l=c(75,40),c=c(40,80), power=1)#
heatcols <- matlab.like2((ultimateplateau+2))#
#heatcols <- c('firebrick4', 'firebrick3', 'firebrick1','orangered1','darkorange1','gold1','yellow','aquamarine1','cyan1','cadetblue1', 'deepskyblue', 'dodgerblue1', 'royalblue1')#red -> yellow -> blue#
id.totalnotseeded <- which(abundance_mat[,(numsteps+1)] == 0)#
png(paste0("Realized_CU_50R_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("50 Reefs +", numsteps, " Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#
png(paste0("Realized_CU_50R_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot(world, main = paste("50 Reefs +", numsteps, " Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
#pacific centred versions of the above#
png(paste0("PCentre_Realized_CU_50R_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("50 Reefs +", numsteps, " Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_CU_50R_Reseed_BRB_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("50 Reefs +", numsteps, " Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="light blue",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_CU_50R_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("50 Reefs +", numsteps, " Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
points(reefdata$Longitude_corrected[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
##Proportion of the initial clusters that have been rebuilt?#
#
#Histogram of percentage of each of the initial clusters that have been rebuilt#
#load in original cluster designations#
#reefdata2 <- reefdata[,c(2,3,4)]#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
#range(clusters(g_orig, mode = "weak")$membership)[2] #604 clusters#
#
#reefdata is in the same order as abundance_mat (see: use + construction of id.reefs)#
#so can add in another column to reefdata2 with abundance y/n re: re-seeding#
#reefdata2 <- reefdata[,c(2,3,4)]#
reefdata2$final_abund_50r <- 1#
reefdata2$final_abund_50r[id.totalnotseeded] <- 0#
head(reefdata2$final_abund_50r)#
#
#reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
for(i in 1:(clusters(g_orig, mode = "weak")$no)){#
	reseededclusters$num_reseeded_50r[i] <- sum(reefdata2$final_abund_50r[reefdata2$cl.m == i])#
	reseededclusters$per_reseeded_50r[i] <- (reseededclusters$num_reseeded_50r[i]/reseededclusters$clustersize[i])*100#
}#
png(paste0("Realized_CU_50R_HistPerReseeded_",numsteps,"steps.png"))#
hist(reseededclusters$per_reseeded_50r, main = "Percentages of Each Original Cluster that was Re-seeded", xlab = "Percent Re-seeded")#
dev.off()#
#
abundance_mat <- NA#
plateaupoint <- 500
#RESEEDING FROM PREDICTED SCENARIO#
ord <- order(reefdata$score) #lowest to highest#
numsteps <- 50#
num_remove <- 434#
num_iter <- 20#
final_reef <- (num_iter*num_remove)#
reefdata$num <- seq(1,12292,by=1)#
starterreefs <- reefdata$num[-ord[1:final_reef]]#
reefdata$num <- NULL#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = (numsteps+1)) #50 time steps#
abundance_mat[,1][starterreefs] <- 100 #time step 0: assign all the starterreefs to an abundance of 100#
#
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#Plot the number that were re-seeded over time#
stop <- "no"#
numreseeded_pr <- rep(NA,(numsteps+1))#
numreseeded_pr[1] <- 0#
for(i in 2:(numsteps+1)){#
numreseeded_pr[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[starterreefs,i][abundance_mat[starterreefs,i]>0])	#
if((numreseeded_pr[i] <= numreseeded_pr[i-1]) & stop == "no"){ #added 'or' condition to be consistent with the other scenarios#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_pr <- plateaupoint#
#
png(paste0("Realized_CU_Predicted_Reseed_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=numreseeded_pr,main="Realized Predicted Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "# of Reseeded Reefs")#
dev.off()#
#starterreefs + first set seeded - colour the starterreefs green, the rest colour red#
#for(i in 2:(numsteps+1)){#
#id.abund <- which(abundance_mat[,i] > 0)#
#
#png(paste0("Realized_CU_Predicted_Reseed_TS",i-1,"_GR.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
#plot(world, main = paste("Predicted Scenario Final Reefs +",i-1,"Time Step"))#
#points(reefdata$Longitude,reefdata$Latitude,col=alpha("grey",0.2),pch=20,cex=0.2)#
#points(reefdata$Longitude[id.abund],reefdata$Latitude[id.abund],col="red",pch=20,cex=0.2) #
#points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="green",pch=20,cex=0.2)#
#dev.off()#
#}#
#dev.off()#
#
id.abund <- list()#
for(i in 2:(numsteps+1)){#
id.abund[[i]] <- which((abundance_mat[,i] > 0) & (abundance_mat[,(i-1)] == 0))#
id.abund[[i]] <- id.abund[[i]][-starterreefs]#
}#
id.totalnotseeded <- which(abundance_mat[,(numsteps+1)] == 0)#
#heatcols <- diverge_hcl(10)#
#heatcols <- heat_hcl(12,h=c(0,-100), l = c(75,40), c = c(40,80), power = 1)#
#heatcols <- heat_hcl(12,h=c(0,-100),l=c(75,40),c=c(40,80), power=1)#
heatcols <- matlab.like2((ultimateplateau+2))#
#heatcols <- c('firebrick4', 'firebrick3', 'firebrick1','orangered1','darkorange1','gold1','yellow','aquamarine1','cyan1','cadetblue1', 'deepskyblue', 'dodgerblue1', 'royalblue1')#red -> yellow -> blue#
png(paste0("Realized_CU_Predicted_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Predicted Scenario +", numsteps, "Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#
png(paste0("Realized_CU_Predicted_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot(world, main = paste("Predicted Scenario +", numsteps, "Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
#pacific centred versions of the above#
png(paste0("PCentre_Realized_CU_Predicted_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Predicted Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_CU_Predicted_Reseed_BRB_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Predicted Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="light blue",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_Predicted_allblack.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Predicted Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
png(paste0("PCentre_Realized_CU_Predicted_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Predicted Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#
#Histogram of percentage of each of the initial clusters that have been rebuilt#
#load in original cluster designations#
#reefdata2 <- reefdata[,c(2,3,4)]#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
#range(clusters(g_orig, mode = "weak")$membership)[2] #604 clusters#
#
#reefdata is in the same order as abundance_mat (see: use + construction of id.reefs)#
#so can add in another column to reefdata2 with abundance y/n re: re-seeding#
#reefdata2 <- reefdata[,c(2,3,4)]#
reefdata2$final_abund_pr <- 1#
reefdata2$final_abund_pr[id.totalnotseeded] <- 0#
head(reefdata2$final_abund_pr)#
#
#reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
for(i in 1:(clusters(g_orig, mode = "weak")$no)){#
	reseededclusters$num_reseeded_pr[i] <- sum(reefdata2$final_abund_pr[reefdata2$cl.m == i])#
	reseededclusters$per_reseeded_pr[i] <- (reseededclusters$num_reseeded_pr[i]/reseededclusters$clustersize[i])*100#
}#
png(paste0("Realized_CU_Predicted_HistPerReseeded_",numsteps,"steps.png"))#
hist(reseededclusters$per_reseeded_pr, main = "Percentages of Each Original Cluster that was Re-seeded", xlab = "Percent Re-seeded")#
dev.off()#
#
abundance_mat <- NA#
plateaupoint <- 500
#RESEEDING FROM CATASTROPHE SCENARIO#
ord <- order(reefdata$score, decreasing = TRUE) #highest to lowest#
numsteps <- 50#
num_remove <- 434#
num_iter <- 20#
final_reef <- (num_iter*num_remove)#
reefdata$num <- seq(1,12292,by=1)#
starterreefs <- reefdata$num[-ord[1:final_reef]]#
reefdata$num <- NULL#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = (numsteps+1)) #10 time steps#
abundance_mat[,1][starterreefs] <- 100 #time step 0: assign all the starterreefs to an abundance of 100#
#
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#Plot the number that were re-seeded over time#
stop <- "no"#
numreseeded_cr <- rep(NA,(numsteps+1))#
numreseeded_cr[1] <- 0#
for(i in 2:(numsteps+1)){#
numreseeded_cr[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[starterreefs,i][abundance_mat[starterreefs,i]>0])	#
if((numreseeded_cr[i] <= numreseeded_cr[i-1]) & stop == "no"){ #added in the 'or previous = bigger' condition bc of '0' issues#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_cr <- plateaupoint#
#
png(paste0("Realized_CU_Catastrophe_Reseed_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=numreseeded_cr,main="Realized Catastrophe Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "# of Reseeded Reefs")#
dev.off()#
#
#starterreefs + first set seeded - colour the starterreefs green, the rest colour red#
#for(i in 2:(numsteps+1)){#
#id.abund <- which(abundance_mat[,i] > 0)#
#
#png(paste0("Realized_CU_Catastrophe_Reseed_TS",i-1,"_GR.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
#plot(world, main = paste("Catastrophe Scenario Final Reefs +",i-1,"Time Step"))#
#points(reefdata$Longitude,reefdata$Latitude,col=alpha("grey",0.2),pch=20,cex=0.2)#
#points(reefdata$Longitude[id.abund],reefdata$Latitude[id.abund],col="red",pch=20,cex=0.2) #
#points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="green",pch=20,cex=0.2)#
#dev.off()#
#}#
#dev.off()#
#
id.abund <- list()#
for(i in 2:(numsteps+1)){#
id.abund[[i]] <- which((abundance_mat[,i] > 0) & (abundance_mat[,(i-1)] == 0))#
id.abund[[i]] <- id.abund[[i]][-starterreefs]#
}#
id.totalnotseeded <- which(abundance_mat[,(numsteps+1)] == 0)#
#
heatcols <- matlab.like2((ultimateplateau+2))#
#heatcols <- c('firebrick4', 'firebrick3', 'firebrick1','orangered1','darkorange1','gold1','yellow','aquamarine1','cyan1','cadetblue1', 'deepskyblue', 'dodgerblue1', 'royalblue1')#red -> yellow -> blue#
#
png(paste0("Realized_CU_Catastrophe_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Catastrophe Scenario +",numsteps,"Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#
png(paste0("Realized_CU_Catastrophe_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot(world, main = paste("Catastrophe Scenario +",numsteps,"Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
#pacific centred versions of the above#
png(paste0("PCentre_Realized_CU_Catastrophe_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Catastrophe Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_CU_Catastrophe_Reseed_BRB_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Catastrophe Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="light blue",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_Catastrophe_allblack.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Catastrophe Scenario"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
png(paste0("PCentre_Realized_CU_Catastrophe_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Catastrophe Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#Histogram of percentage of each of the initial clusters that have been rebuilt#
#load in original cluster designations#
#reefdata2 <- reefdata[,c(2,3,4)]#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
#range(clusters(g_orig, mode = "weak")$membership)[2] #604 clusters#
#
#reefdata is in the same order as abundance_mat (see: use + construction of id.reefs)#
#so can add in another column to reefdata2 with abundance y/n re: re-seeding#
#reefdata2 <- reefdata[,c(2,3,4)]#
reefdata2$final_abund_cr <- 1#
reefdata2$final_abund_cr[id.totalnotseeded] <- 0#
head(reefdata2$final_abund_cr)#
#
#reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
for(i in 1:(clusters(g_orig, mode = "weak")$no)){#
	reseededclusters$num_reseeded_cr[i] <- sum(reefdata2$final_abund_cr[reefdata2$cl.m == i])#
	reseededclusters$per_reseeded_cr[i] <- (reseededclusters$num_reseeded_cr[i]/reseededclusters$clustersize[i])*100#
}#
png(paste0("Realized_CU_50R_HistPerReseeded_",numsteps,"steps.png"))#
hist(reseededclusters$per_reseeded_cr, main = "Percentages of Each Original Cluster that was Re-seeded", xlab = "Percent Re-seeded")#
dev.off()#
#
abundance_mat <- NA#
#
#plotting all of the numreseeeded from the 3 different 'scenarios' on one graph#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=((numreseeded_50r/12292)*100),main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", col = "green", type = 'l', ylim = c(0,30))#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_pr/12292)*100), col = "brown")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_cr/12292)*100), col  = "pink")#
legend("topleft", c("50 Reefs", "Predicted", "Catastrophe"), col = c("green","brown","pink"), lty = c(1,1,1))#
dev.off()#
#
#Histograms of Percent of each cluster Reseeded all together#
png(paste0("Realized_CU_Full_HistPerReseeded_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
hist(reseededclusters$per_reseeded_50r, main = "50 Reefs", xlab = "Percent Re-seeded", col = "green", ylim = c(0,600))#
hist(reseededclusters$per_reseeded_pr, main = "Predicted", xlab = "Percent Re-seeded",col = "brown", ylim = c(0,600))#
hist(reseededclusters$per_reseeded_cr, main = "Catastrophe", xlab = "Percent Re-seeded", col = "pink", ylim = c(0,600))#
dev.off()#
#
#Histograms of Percent of each cluster Reseeded all together#
png(paste0("Realized_CU_Full_HistNumReseeded_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
hist(reseededclusters$num_reseeded_50r, main = "50 Reefs", xlab = "Number of Cells Re-seeded", col = "green", ylim = c(0,600), xlim = c(0,4000))#
hist(reseededclusters$num_reseeded_pr, main = "Predicted", xlab = "Number of Cells Re-seeded",col = "brown", ylim = c(0,600), xlim = c(0,4000))#
hist(reseededclusters$num_reseeded_cr, main = "Catastrophe", xlab = "Number of Cells Re-seeded", col = "pink", ylim = c(0,600), xlim = c(0,4000))#
dev.off()#
#
#Histograms of Percent of each cluster Reseeded all together, 0s removed#
png(paste0("Realized_CU_Full_HistPerReseeded_no0_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
hist(reseededclusters$per_reseeded_50r[which(reseededclusters$per_reseeded_50r > 0)], main = "50 Reefs (no 0s)", xlab = "Percent Re-seeded", col = "green", ylim = c(0,200))#
hist(reseededclusters$per_reseeded_pr[which(reseededclusters$per_reseeded_pr > 0)], main = "Predicted (no 0s)", xlab = "Percent Re-seeded",col = "brown", ylim = c(0,200))#
hist(reseededclusters$per_reseeded_cr[which(reseededclusters$per_reseeded_cr > 0)], main = "Catastrophe (no 0s)", xlab = "Percent Re-seeded", col = "pink", ylim = c(0,200))#
dev.off()#
#
png(paste0("Realized_CU_Full_PerReseeded_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
plot(x = reseededclusters$clustersize,y = reseededclusters$per_reseeded_50r, main = "50 Reefs", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "green", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_pr, x = reseededclusters$clustersize, main = "Predicted", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "brown", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_cr, x = reseededclusters$clustersize, main = "Catastrophe", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "pink", ylim = c(0,100), pch=20)#
dev.off()#
#
png(paste0("Realized_CU_Full_NumReseeded_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
plot(x = reseededclusters$clustersize,y = reseededclusters$num_reseeded_50r, main = "50 Reefs", ylab = "Number of Cells Re-seeded", xlab = "Cluster Size", col = "green", pch=20)#
plot(y = reseededclusters$num_reseeded_pr, x = reseededclusters$clustersize, main = "Predicted", ylab = "Number of Cells Re-seeded", xlab = "Cluster Size", col = "brown", pch=20)#
plot(y = reseededclusters$num_reseeded_cr, x = reseededclusters$clustersize, main = "Catastrophe", ylab = "Number of Cells Re-seeded", xlab = "Cluster Size", col = "pink", pch=20)#
dev.off()#
#
png(paste0("Realized_CU_Full_PerReseeded_no0_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
plot(x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_50r > 0)],y = reseededclusters$per_reseeded_50r[which(reseededclusters$per_reseeded_50r > 0)], main = "50 Reefs (no 0s)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "green", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_pr[which(reseededclusters$per_reseeded_pr > 0)], x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_pr > 0)], main = "Predicted (no 0s)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "brown", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_cr[which(reseededclusters$per_reseeded_cr > 0)], x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_cr > 0)], main = "Catastrophe (no 0s)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "pink", ylim = c(0,100), pch=20)#
dev.off()#
#
png(paste0("Realized_CU_Full_PerReseeded_no0_nobigcluster",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
plot(x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_50r > 0 & reseededclusters$clustersize < 1000)],y = reseededclusters$per_reseeded_50r[which(reseededclusters$per_reseeded_50r > 0 & reseededclusters$clustersize < 1000)], main = "50 Reefs (no 0s, no big cluster)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "green", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_pr[which(reseededclusters$per_reseeded_pr > 0 & reseededclusters$clustersize < 1000)], x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_pr > 0 & reseededclusters$clustersize < 1000)], main = "Predicted (no 0s, no big cluster)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "brown", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_cr[which(reseededclusters$per_reseeded_cr > 0 & reseededclusters$clustersize < 1000)], x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_cr > 0 & reseededclusters$clustersize < 1000)], main = "Catastrophe (no 0s, no big cluster)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "pink", ylim = c(0,100), pch=20)#
dev.off()
#RESEEDING FROM RANDOM SCENARIO#
set.seed(2)#
abundmatlist <- starterreefslist <- numreseededrrlist <- id.totalnotseeded <- perreseededrr <- list()#
numsteps <- 50#
num_remove <- 434#
num_iter <- 20#
random_iter <- 100#
final_reef <- (num_iter*num_remove)#
plateaupoint <- 500#
plateaupoint_rr <- rep(NA,random_iter)#
reefdata$num <- seq(1,12292,by=1)#
for(j in 1:random_iter){#
ord <- sample(seq(1,length(reefdata$score),by=1))#
starterreefs <- reefdata$num[-ord[1:final_reef]]#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = (numsteps+1)) #50 time steps#
abundance_mat[,1][starterreefs] <- 100 #time step 0: assign all the starterreefs to an abundance of 100#
#
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#
abundmatlist[[j]] <- abundance_mat#
starterreefslist[[j]] <- starterreefs#
#Plot the number that were re-seeded over time#
stop <- "no"#
numreseeded_rr <- rep(NA,(numsteps+1))#
numreseeded_rr[1] <- 0#
for(i in 2:(numsteps+1)){#
numreseeded_rr[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[starterreefs,i][abundance_mat[starterreefs,i]>0])	#
if((numreseeded_rr[i] <= numreseeded_rr[i-1]) & stop == "no"){ #OR if more reseeded in the previous step (to deal with the flip-flopping)#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_rr[j] <- plateaupoint#
numreseededrrlist[[j]] <- numreseeded_rr#
#
id.totalnotseeded[[j]] <- which(abundance_mat[,(numsteps+1)] == 0)#
}#
#
meanplateauptrr <- mean(plateaupoint_rr)#
#
numreseededrr_mean <- rep(NA,(numsteps+1))#
numreseededrr_sd <- rep(NA,(numsteps+1))#
set <- rep(NA,random_iter)#
for(i in 1:(numsteps+1)){#
	for(j in 1:random_iter){#
	set[j] <- numreseededrrlist[[j]][i]#
	}#
	numreseededrr_mean[i] <- mean(set)#
	numreseededrr_sd[i] <- sd(set)#
	set <- rep(NA,random_iter)	#
}#
png(paste0("Realized_CU_Random_Reseed_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=numreseededrr_mean,main="Realized Random Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "# of Reseeded Reefs", type = "n")#
for(i in 1:random_iter){#
	lines(x = seq(1,(numsteps+1),by=1),y = numreseededrrlist[[i]],col = alpha("blue", 0.2))#
}#
points(x=seq(1,(numsteps+1),by=1),y=numreseededrr_mean, pch=20)#
dev.off()#
#
#NOT SURE IF THIS MAKES SENSE TO PLOT...NEED TO THINK ABOUT#
#Histogram of percentage of each of the initial clusters that have been rebuilt#
#load in original cluster designations#
#reefdata2 <- reefdata[,c(2,3,4)]#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
#range(clusters(g_orig, mode = "weak")$membership)[2] #604 clusters#
#
#reefdata is in the same order as abundance_mat (see: use + construction of id.reefs)#
#so can add in another column to reefdata2 with abundance y/n re: re-seeding#
#reefdata2 <- reefdata[,c(2,3,4)]#
#
for(j in 1:random_iter){#
reefdata2$final_abund_rr <- 1#
reefdata2$final_abund_rr[id.totalnotseeded[[j]]] <- 0#
head(reefdata2$final_abund_rr)#
#
#reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
for(i in 1:(clusters(g_orig, mode = "weak")$no)){#
	reseededclusters$num_reseeded_rr[i] <- sum(reefdata2$final_abund_rr[reefdata2$cl.m == i])#
	reseededclusters$per_reseeded_rr[i] <- (reseededclusters$num_reseeded_rr[i]/reseededclusters$clustersize[i])*100#
}#
perreseededrr[[j]] <- reseededclusters$per_reseeded_rr#
}#
#
perreseededrr_mean <- rep(NA,(numsteps+1))#
perreseededrr_sd <- rep(NA,(numsteps+1))#
set <- rep(NA,random_iter)#
for(i in 1:(numsteps+1)){#
	for(j in 1:random_iter){#
	set[j] <- perreseededrr[[j]][i]#
	}#
	perreseededrr_mean[i] <- mean(set)#
	perreseededrr_sd[i] <- sd(set)#
	set <- rep(NA,random_iter)	#
}#
#
png(paste0("Realized_CU_MeanRandom_HistPerReseeded_",numsteps,"steps.png"))#
hist(perreseededrr_mean, main = "Mean Percentage of Each Original Cluster that was Re-seeded", xlab = "Percent Re-seeded")#
dev.off()#
#
abundance_mat <- NA#
plateaupoint <- 500#
#
#plotting all of the numreseeeded from the 4 different 'scenarios' on one graph#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=((numreseeded_50r/12292)*100),main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", col = "green", type = 'l', ylim = c(0,60))#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_pr/12292)*100), col = "brown")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_cr/12292)*100), col  = "pink")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseededrr_mean/12292)*100), col  = "red",lty =3)#
legend("bottomright", c("50 Reefs", "Predicted", "Catastrophe","Random"), col = c("green","brown","pink","red"), lty = c(1,1,1,3))#
dev.off()#
#
#plotting all of the numreseeeded from the 4 different 'scenarios' on one graph - PERCENTAGE OF RE-SEEDED NOT INCLUDING STARTER REEFS#
numpossiblereseeded50r <- 12292-length(id.50reefs)#
numpossiblereseeded <- 12292-(12292 - final_reef) #12292 - final_reef = number started with in the predicted and catastrophe situations#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios_fixedpercentages.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=((numreseeded_50r/numpossiblereseeded50r)*100),main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", col = "green", type = 'l', ylim = c(0,80))#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_pr/numpossiblereseeded)*100), col = "brown")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_cr/numpossiblereseeded)*100), col  = "pink")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseededrr_mean/numpossiblereseeded)*100), col  = "red",lty =3)#
legend("bottomright", c("50 Reefs", "Predicted", "Catastrophe","Random"), col = c("green","brown","pink","red"), lty = c(1,1,1,3))#
dev.off()#
#
#for appraisal#
#plotting all of the numreseeeded from the 4 different 'scenarios' on one graph - total seeded as a PERCENTTAGE OF TOTAL REEFS#
#12292 - final_reef = number started with in the predicted and catastrophe situations#
initialreefs = 12292 - final_reef#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios_totalpercentages.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_50r+length(id.50reefs))/12292)*100),main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", col = "green", type = 'l', ylim = c(20,100), lwd = 3)#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_pr + initialreefs)/12292)*100), col = "blue",lwd = 3)#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_cr + initialreefs)/12292)*100), col  = "orange", lwd = 3)#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseededrr_mean + initialreefs)/12292)*100), col  = "red",lty =3, lwd = 3)#
legend("bottomright", c("50 Reefs", "PCS Hyp", "Cautionary Hyp","Random Hyp"), col = c("green","blue","orange","red"), lty = c(1,1,1,3), lwd = c(3,3,3,3))#
dev.off()#
#
#no 50 reefs for GCC poster#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios_totalpercentages_no50r.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_pr + initialreefs)/12292)*100), col = "blue",lwd = 3,main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", type = 'l', ylim = c(20,100))#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_cr + initialreefs)/12292)*100), col  = "orange", lwd = 3)#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseededrr_mean + initialreefs)/12292)*100), col  = "red",lty =3, lwd = 3)#
legend("bottomright", c("PCS Hyp", "Cautionary Hyp","Random Hyp"), col = c("blue","orange","red"), lty = c(1,1,3), lwd = c(3,3,3))#
dev.off()#
#
#not including the 50 reefs scenario#
#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios_fixedpercentages_no50r.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=((numreseeded_pr/numpossiblereseeded)*100), col = "green",main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", type = 'l', ylim = c(0,80))#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_cr/numpossiblereseeded)*100), col  = "brown")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseededrr_mean/numpossiblereseeded)*100), col  = "red",lty =3)#
legend("bottomright", c("Predicted", "Catastrophe","Random"), col = c("green","brown","red"), lty = c(1,1,3))#
dev.off()
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(colorRamps)#
library(maps)#
#
plot.map<- function(database,center,...){#
    Obj <- map(database,...,plot=F)#
    coord <- cbind(Obj[[1]],Obj[[2]])#
#
    # split up the coordinates#
    id <- rle(!is.na(coord[,1]))#
    id <- matrix(c(1,cumsum(id$lengths)),ncol=2,byrow=T)#
    polygons <- apply(id,1,function(i){coord[i[1]:i[2],]})#
#
    # split up polygons that differ too much#
    polygons <- lapply(polygons,function(x){#
        x[,1] <- x[,1] + center#
        x[,1] <- ifelse(x[,1]>180,x[,1]-360,x[,1])#
        if(sum(diff(x[,1])>300,na.rm=T) >0){#
          id <- x[,1] < 0#
          x <- rbind(x[id,],c(NA,NA),x[!id,])#
       }#
       x#
    })#
    # reconstruct the object#
    polygons <- do.call(rbind,polygons)#
    Obj[[1]] <- polygons[,1]#
    Obj[[2]] <- polygons[,2]#
#
    map(Obj,...)#
}#
###REALIZED CONNECTIVITY####
#load in the shape file with all of the data#
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
dim(reefdata_full)#
reefdata <- reefdata_full[,c(3:6,34,13:28)]#
head(reefdata)#
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")#
#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)#
#
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
connmat_reduced <- connmat_thresholder#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2#
#
#correct the longitude#
reefdata$Longitude[reefdata$Longitude > 180] <- reefdata$Longitude[reefdata$Longitude > 180] - 360#
#
#for plotting pacific centred maps#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
#range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360#
world <- readOGR(dsn = "~/Dropbox/University of Toronto/Research Related/Code from Marco 6.2018 mediterranean larval connectivity/worldcountryshapeetc", layer = "ne_110m_admin_0_countries")#
#
#note: plateaupoint_cr = 26, plateaupoint_50r = 23, plateaupoint_pr = 23 so final plateaupoint = 23#
ultimateplateau <- 26#
reefdata2 <- reefdata[,c(2,3,4)]#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
#
#POSSIBLE THING TO DO: Cluster size of rebuilt clusters? like, size of the clusters as they exist at the end...not the amount of each of the former clusters that has been rebuilt but the size of the clusters as they are (i think the percentage rebuilt might be more informative? idk)#
#
#CHANGE TO TIM.COLOURS?#
#
#RESEEDING FROM 50 REEFS#
#Start with just the 50 reefs#
numsteps <-50#
id.50reefs <- which(!is.na(reefdata$BCU_Name)) #this IDs the rows with 50 reefs#
length(id.50reefs) #3334#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = numsteps+1) #10 time steps#
abundance_mat[,1][id.50reefs] <- 100 #time step 0: assign all the 50 reefs to an abundance of 100
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#
stop <- "no"#
#Plot the number that were re-seeded over time#
numreseeded_50r <- rep(NA,(numsteps+1))#
numreseeded_50r[1] <- 0#
for(i in 2:(numsteps + 1)){#
#line below could be simplified to just be length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[id.50reefs,i]) but whatever, same for all of the other scenarios#
numreseeded_50r[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[id.50reefs,i][abundance_mat[id.50reefs,i]>0])	#
if((numreseeded_50r[i] <= numreseeded_50r[i-1]) & stop == "no"){ #added the 'or' condition bc of some of the other cases needing it#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_50r <- plateaupoint
plateaupoint_50r
id.50reefs
length(id.50reefs)
head(reefdata)
reefdata$BCU_ID[1:100]
id.50reefs <- which(reefdata$BCU_ID > 0) #this IDs the rows with 50 reefs#
length(id.50reefs) #3334
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(colorRamps)#
library(maps)#
#
plot.map<- function(database,center,...){#
    Obj <- map(database,...,plot=F)#
    coord <- cbind(Obj[[1]],Obj[[2]])#
#
    # split up the coordinates#
    id <- rle(!is.na(coord[,1]))#
    id <- matrix(c(1,cumsum(id$lengths)),ncol=2,byrow=T)#
    polygons <- apply(id,1,function(i){coord[i[1]:i[2],]})#
#
    # split up polygons that differ too much#
    polygons <- lapply(polygons,function(x){#
        x[,1] <- x[,1] + center#
        x[,1] <- ifelse(x[,1]>180,x[,1]-360,x[,1])#
        if(sum(diff(x[,1])>300,na.rm=T) >0){#
          id <- x[,1] < 0#
          x <- rbind(x[id,],c(NA,NA),x[!id,])#
       }#
       x#
    })#
    # reconstruct the object#
    polygons <- do.call(rbind,polygons)#
    Obj[[1]] <- polygons[,1]#
    Obj[[2]] <- polygons[,2]#
#
    map(Obj,...)#
}#
###REALIZED CONNECTIVITY####
#load in the shape file with all of the data#
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
dim(reefdata_full)#
reefdata <- reefdata_full[,c(3:6,34,13:28)]#
head(reefdata)#
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")#
#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)#
#
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
connmat_reduced <- connmat_thresholder#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2#
#
#correct the longitude#
reefdata$Longitude[reefdata$Longitude > 180] <- reefdata$Longitude[reefdata$Longitude > 180] - 360#
#
#for plotting pacific centred maps#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
#range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360#
world <- readOGR(dsn = "~/Dropbox/University of Toronto/Research Related/Code from Marco 6.2018 mediterranean larval connectivity/worldcountryshapeetc", layer = "ne_110m_admin_0_countries")#
#
#note: plateaupoint_cr = 26, plateaupoint_50r = 23, plateaupoint_pr = 23 so final plateaupoint = 23#
ultimateplateau <- 26#
reefdata2 <- reefdata[,c(2,3,4)]#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
#
#POSSIBLE THING TO DO: Cluster size of rebuilt clusters? like, size of the clusters as they exist at the end...not the amount of each of the former clusters that has been rebuilt but the size of the clusters as they are (i think the percentage rebuilt might be more informative? idk)#
#
#CHANGE TO TIM.COLOURS?#
#
#RESEEDING FROM 50 REEFS#
#Start with just the 50 reefs#
numsteps <-50#
id.50reefs <- which(reefdata$BCU_ID > 0) #this IDs the rows with 50 reefs#
length(id.50reefs) #3334#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = numsteps+1) #10 time steps#
abundance_mat[,1][id.50reefs] <- 100 #time step 0: assign all the 50 reefs to an abundance of 100#
#
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#
stop <- "no"#
#Plot the number that were re-seeded over time#
numreseeded_50r <- rep(NA,(numsteps+1))#
numreseeded_50r[1] <- 0#
for(i in 2:(numsteps + 1)){#
#line below could be simplified to just be length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[id.50reefs,i]) but whatever, same for all of the other scenarios#
numreseeded_50r[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[id.50reefs,i][abundance_mat[id.50reefs,i]>0])	#
if((numreseeded_50r[i] <= numreseeded_50r[i-1]) & stop == "no"){ #added the 'or' condition bc of some of the other cases needing it#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_50r <- plateaupoint#
png(paste0("Realized_CU_50R_Reseed_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=numreseeded_50r,main="Realized 50 Reefs Reseeded over Time",xlab = "Time Step", ylab = "# of Reseeded Reefs")#
dev.off()#
#
#starterreefs + first set seeded - colour the starterreefs green, the rest colour red#
#
#LOTS of plots for 50 steps...#
#for(i in 2:101){#
#id.abund <- which(abundance_mat[,i] > 0)#
#
#png(paste0("Realized_CU_50R_Reseed_TS",i-1,"_GR.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
#plot(world, main = paste("50 Reefs +",i-1,"Time Step"))#
#points(reefdata$Longitude,reefdata$Latitude,col=alpha("grey",0.2),pch=20,cex=0.2)#
#points(reefdata$Longitude[id.abund],reefdata$Latitude[id.abund],col="red",pch=20,cex=0.2) #
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2)#
#dev.off()#
#}#
#dev.off()#
#
id.abund <- list()#
for(i in 2:(numsteps+1)){#
id.abund[[i]] <- which((abundance_mat[,i] > 0) & (abundance_mat[,(i-1)] == 0))#
id.abund[[i]] <- id.abund[[i]][-id.50reefs]#
}#
#heatcols <- diverge_hcl(10)#
#heatcols <- heat_hcl(12,h=c(0,-100), l = c(75,40), c = c(40,80), power = 1)#
#heatcols <- heat_hcl(12,h=c(0,-100),l=c(75,40),c=c(40,80), power=1)#
heatcols <- matlab.like2((ultimateplateau+2))#
#heatcols <- c('firebrick4', 'firebrick3', 'firebrick1','orangered1','darkorange1','gold1','yellow','aquamarine1','cyan1','cadetblue1', 'deepskyblue', 'dodgerblue1', 'royalblue1')#red -> yellow -> blue#
id.totalnotseeded <- which(abundance_mat[,(numsteps+1)] == 0)#
png(paste0("Realized_CU_50R_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("50 Reefs +", numsteps, " Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#
png(paste0("Realized_CU_50R_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot(world, main = paste("50 Reefs +", numsteps, " Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
#pacific centred versions of the above#
png(paste0("PCentre_Realized_CU_50R_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("50 Reefs +", numsteps, " Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_CU_50R_Reseed_BRB_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("50 Reefs +", numsteps, " Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="light blue",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_CU_50R_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("50 Reefs +", numsteps, " Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
points(reefdata$Longitude_corrected[id.50reefs],reefdata$Latitude[id.50reefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
##Proportion of the initial clusters that have been rebuilt?#
#
#Histogram of percentage of each of the initial clusters that have been rebuilt#
#load in original cluster designations#
#reefdata2 <- reefdata[,c(2,3,4)]#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
#range(clusters(g_orig, mode = "weak")$membership)[2] #604 clusters#
#
#reefdata is in the same order as abundance_mat (see: use + construction of id.reefs)#
#so can add in another column to reefdata2 with abundance y/n re: re-seeding#
#reefdata2 <- reefdata[,c(2,3,4)]#
reefdata2$final_abund_50r <- 1#
reefdata2$final_abund_50r[id.totalnotseeded] <- 0#
head(reefdata2$final_abund_50r)#
#
#reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
for(i in 1:(clusters(g_orig, mode = "weak")$no)){#
	reseededclusters$num_reseeded_50r[i] <- sum(reefdata2$final_abund_50r[reefdata2$cl.m == i])#
	reseededclusters$per_reseeded_50r[i] <- (reseededclusters$num_reseeded_50r[i]/reseededclusters$clustersize[i])*100#
}#
png(paste0("Realized_CU_50R_HistPerReseeded_",numsteps,"steps.png"))#
hist(reseededclusters$per_reseeded_50r, main = "Percentages of Each Original Cluster that was Re-seeded", xlab = "Percent Re-seeded")#
dev.off()#
#
abundance_mat <- NA#
plateaupoint <- 500
#RESEEDING FROM PREDICTED SCENARIO#
ord <- order(reefdata$score) #lowest to highest#
numsteps <- 50#
num_remove <- 434#
num_iter <- 20#
final_reef <- (num_iter*num_remove)#
reefdata$num <- seq(1,12292,by=1)#
starterreefs <- reefdata$num[-ord[1:final_reef]]#
reefdata$num <- NULL#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = (numsteps+1)) #50 time steps#
abundance_mat[,1][starterreefs] <- 100 #time step 0: assign all the starterreefs to an abundance of 100#
#
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#Plot the number that were re-seeded over time#
stop <- "no"#
numreseeded_pr <- rep(NA,(numsteps+1))#
numreseeded_pr[1] <- 0#
for(i in 2:(numsteps+1)){#
numreseeded_pr[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[starterreefs,i][abundance_mat[starterreefs,i]>0])	#
if((numreseeded_pr[i] <= numreseeded_pr[i-1]) & stop == "no"){ #added 'or' condition to be consistent with the other scenarios#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_pr <- plateaupoint#
#
png(paste0("Realized_CU_Predicted_Reseed_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=numreseeded_pr,main="Realized Predicted Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "# of Reseeded Reefs")#
dev.off()#
#starterreefs + first set seeded - colour the starterreefs green, the rest colour red#
#for(i in 2:(numsteps+1)){#
#id.abund <- which(abundance_mat[,i] > 0)#
#
#png(paste0("Realized_CU_Predicted_Reseed_TS",i-1,"_GR.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
#plot(world, main = paste("Predicted Scenario Final Reefs +",i-1,"Time Step"))#
#points(reefdata$Longitude,reefdata$Latitude,col=alpha("grey",0.2),pch=20,cex=0.2)#
#points(reefdata$Longitude[id.abund],reefdata$Latitude[id.abund],col="red",pch=20,cex=0.2) #
#points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="green",pch=20,cex=0.2)#
#dev.off()#
#}#
#dev.off()#
#
id.abund <- list()#
for(i in 2:(numsteps+1)){#
id.abund[[i]] <- which((abundance_mat[,i] > 0) & (abundance_mat[,(i-1)] == 0))#
id.abund[[i]] <- id.abund[[i]][-starterreefs]#
}#
id.totalnotseeded <- which(abundance_mat[,(numsteps+1)] == 0)#
#heatcols <- diverge_hcl(10)#
#heatcols <- heat_hcl(12,h=c(0,-100), l = c(75,40), c = c(40,80), power = 1)#
#heatcols <- heat_hcl(12,h=c(0,-100),l=c(75,40),c=c(40,80), power=1)#
heatcols <- matlab.like2((ultimateplateau+2))#
#heatcols <- c('firebrick4', 'firebrick3', 'firebrick1','orangered1','darkorange1','gold1','yellow','aquamarine1','cyan1','cadetblue1', 'deepskyblue', 'dodgerblue1', 'royalblue1')#red -> yellow -> blue#
png(paste0("Realized_CU_Predicted_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Predicted Scenario +", numsteps, "Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#
png(paste0("Realized_CU_Predicted_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot(world, main = paste("Predicted Scenario +", numsteps, "Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
#pacific centred versions of the above#
png(paste0("PCentre_Realized_CU_Predicted_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Predicted Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_CU_Predicted_Reseed_BRB_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Predicted Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="light blue",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_Predicted_allblack.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Predicted Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
png(paste0("PCentre_Realized_CU_Predicted_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Predicted Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#
#Histogram of percentage of each of the initial clusters that have been rebuilt#
#load in original cluster designations#
#reefdata2 <- reefdata[,c(2,3,4)]#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
#range(clusters(g_orig, mode = "weak")$membership)[2] #604 clusters#
#
#reefdata is in the same order as abundance_mat (see: use + construction of id.reefs)#
#so can add in another column to reefdata2 with abundance y/n re: re-seeding#
#reefdata2 <- reefdata[,c(2,3,4)]#
reefdata2$final_abund_pr <- 1#
reefdata2$final_abund_pr[id.totalnotseeded] <- 0#
head(reefdata2$final_abund_pr)#
#
#reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
for(i in 1:(clusters(g_orig, mode = "weak")$no)){#
	reseededclusters$num_reseeded_pr[i] <- sum(reefdata2$final_abund_pr[reefdata2$cl.m == i])#
	reseededclusters$per_reseeded_pr[i] <- (reseededclusters$num_reseeded_pr[i]/reseededclusters$clustersize[i])*100#
}#
png(paste0("Realized_CU_Predicted_HistPerReseeded_",numsteps,"steps.png"))#
hist(reseededclusters$per_reseeded_pr, main = "Percentages of Each Original Cluster that was Re-seeded", xlab = "Percent Re-seeded")#
dev.off()#
#
abundance_mat <- NA#
plateaupoint <- 500#
#RESEEDING FROM CATASTROPHE SCENARIO#
ord <- order(reefdata$score, decreasing = TRUE) #highest to lowest#
numsteps <- 50#
num_remove <- 434#
num_iter <- 20#
final_reef <- (num_iter*num_remove)#
reefdata$num <- seq(1,12292,by=1)#
starterreefs <- reefdata$num[-ord[1:final_reef]]#
reefdata$num <- NULL#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = (numsteps+1)) #10 time steps#
abundance_mat[,1][starterreefs] <- 100 #time step 0: assign all the starterreefs to an abundance of 100#
#
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#Plot the number that were re-seeded over time#
stop <- "no"#
numreseeded_cr <- rep(NA,(numsteps+1))#
numreseeded_cr[1] <- 0#
for(i in 2:(numsteps+1)){#
numreseeded_cr[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[starterreefs,i][abundance_mat[starterreefs,i]>0])	#
if((numreseeded_cr[i] <= numreseeded_cr[i-1]) & stop == "no"){ #added in the 'or previous = bigger' condition bc of '0' issues#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_cr <- plateaupoint#
#
png(paste0("Realized_CU_Catastrophe_Reseed_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=numreseeded_cr,main="Realized Catastrophe Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "# of Reseeded Reefs")#
dev.off()#
#
#starterreefs + first set seeded - colour the starterreefs green, the rest colour red#
#for(i in 2:(numsteps+1)){#
#id.abund <- which(abundance_mat[,i] > 0)#
#
#png(paste0("Realized_CU_Catastrophe_Reseed_TS",i-1,"_GR.png"),width=10,height=10,units="cm",res=1000,pointsize=4)#
#plot(world, main = paste("Catastrophe Scenario Final Reefs +",i-1,"Time Step"))#
#points(reefdata$Longitude,reefdata$Latitude,col=alpha("grey",0.2),pch=20,cex=0.2)#
#points(reefdata$Longitude[id.abund],reefdata$Latitude[id.abund],col="red",pch=20,cex=0.2) #
#points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="green",pch=20,cex=0.2)#
#dev.off()#
#}#
#dev.off()#
#
id.abund <- list()#
for(i in 2:(numsteps+1)){#
id.abund[[i]] <- which((abundance_mat[,i] > 0) & (abundance_mat[,(i-1)] == 0))#
id.abund[[i]] <- id.abund[[i]][-starterreefs]#
}#
id.totalnotseeded <- which(abundance_mat[,(numsteps+1)] == 0)#
#
heatcols <- matlab.like2((ultimateplateau+2))#
#heatcols <- c('firebrick4', 'firebrick3', 'firebrick1','orangered1','darkorange1','gold1','yellow','aquamarine1','cyan1','cadetblue1', 'deepskyblue', 'dodgerblue1', 'royalblue1')#red -> yellow -> blue#
#
png(paste0("Realized_CU_Catastrophe_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot(world, main = paste("Catastrophe Scenario +",numsteps,"Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#
png(paste0("Realized_CU_Catastrophe_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot(world, main = paste("Catastrophe Scenario +",numsteps,"Time Steps"), lwd = 0.000002, col = "gainsboro") #lwd = 0.2#
points(reefdata$Longitude[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
#points(reefdata$Longitude[id.50reefs],reefdata$Latitude[id.50reefs],col="green",pch=20,cex=0.2) #misleading#
points(reefdata$Longitude[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
#pacific centred versions of the above#
png(paste0("PCentre_Realized_CU_Catastrophe_Reseed_DiffCol_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Catastrophe Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_CU_Catastrophe_Reseed_BRB_",numsteps,"steps_large.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Catastrophe Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="light blue",pch=20,cex=0.2) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col="red",pch=20,cex=0.2)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
#
png(paste0("PCentre_Realized_Catastrophe_allblack.png"),width=20,height=20,units="cm",res=1500,pointsize=4) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Catastrophe Scenario"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=20,cex=0.2) #not great but maybe better?#
dev.off()#
png(paste0("PCentre_Realized_CU_Catastrophe_Reseed_DiffCol_",numsteps,"steps.png"),width=20,height=20,units="cm",res=1500) #res=1000#
plot.map("world", center=newcentre, col="gainsboro",main = paste("Catastrophe Scenario +", numsteps, "Time Steps"),bg="white",lwd = 0.000002,#
   fill=TRUE,ylim=c(-60,90),mar=c(0,0,0,0))#
points(reefdata$Longitude_corrected[id.totalnotseeded],reefdata$Latitude[id.totalnotseeded],col="gray67",pch=15,cex=0.03) #cex=0.05#
for(i in 2:(numsteps+1)){#
points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[ultimateplateau+2],pch=15,cex=0.03)#
if(i <= plateaupoint){#
	points(reefdata$Longitude_corrected[id.abund[[i]]],reefdata$Latitude[id.abund[[i]]],col=heatcols[i],pch=15,cex=0.03)	#
}#
}#
points(reefdata$Longitude_corrected[starterreefs],reefdata$Latitude[starterreefs],col="black",pch=15,cex=0.03) #not great but maybe better?#
dev.off()#
#Histogram of percentage of each of the initial clusters that have been rebuilt#
#load in original cluster designations#
#reefdata2 <- reefdata[,c(2,3,4)]#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
#range(clusters(g_orig, mode = "weak")$membership)[2] #604 clusters#
#
#reefdata is in the same order as abundance_mat (see: use + construction of id.reefs)#
#so can add in another column to reefdata2 with abundance y/n re: re-seeding#
#reefdata2 <- reefdata[,c(2,3,4)]#
reefdata2$final_abund_cr <- 1#
reefdata2$final_abund_cr[id.totalnotseeded] <- 0#
head(reefdata2$final_abund_cr)#
#
#reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
for(i in 1:(clusters(g_orig, mode = "weak")$no)){#
	reseededclusters$num_reseeded_cr[i] <- sum(reefdata2$final_abund_cr[reefdata2$cl.m == i])#
	reseededclusters$per_reseeded_cr[i] <- (reseededclusters$num_reseeded_cr[i]/reseededclusters$clustersize[i])*100#
}#
png(paste0("Realized_CU_50R_HistPerReseeded_",numsteps,"steps.png"))#
hist(reseededclusters$per_reseeded_cr, main = "Percentages of Each Original Cluster that was Re-seeded", xlab = "Percent Re-seeded")#
dev.off()#
#
abundance_mat <- NA#
#
#plotting all of the numreseeeded from the 3 different 'scenarios' on one graph#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=((numreseeded_50r/12292)*100),main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", col = "green", type = 'l', ylim = c(0,30))#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_pr/12292)*100), col = "brown")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_cr/12292)*100), col  = "pink")#
legend("topleft", c("50 Reefs", "Predicted", "Catastrophe"), col = c("green","brown","pink"), lty = c(1,1,1))#
dev.off()#
#
#Histograms of Percent of each cluster Reseeded all together#
png(paste0("Realized_CU_Full_HistPerReseeded_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
hist(reseededclusters$per_reseeded_50r, main = "50 Reefs", xlab = "Percent Re-seeded", col = "green", ylim = c(0,600))#
hist(reseededclusters$per_reseeded_pr, main = "Predicted", xlab = "Percent Re-seeded",col = "brown", ylim = c(0,600))#
hist(reseededclusters$per_reseeded_cr, main = "Catastrophe", xlab = "Percent Re-seeded", col = "pink", ylim = c(0,600))#
dev.off()#
#
#Histograms of Percent of each cluster Reseeded all together#
png(paste0("Realized_CU_Full_HistNumReseeded_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
hist(reseededclusters$num_reseeded_50r, main = "50 Reefs", xlab = "Number of Cells Re-seeded", col = "green", ylim = c(0,600), xlim = c(0,4000))#
hist(reseededclusters$num_reseeded_pr, main = "Predicted", xlab = "Number of Cells Re-seeded",col = "brown", ylim = c(0,600), xlim = c(0,4000))#
hist(reseededclusters$num_reseeded_cr, main = "Catastrophe", xlab = "Number of Cells Re-seeded", col = "pink", ylim = c(0,600), xlim = c(0,4000))#
dev.off()#
#
#Histograms of Percent of each cluster Reseeded all together, 0s removed#
png(paste0("Realized_CU_Full_HistPerReseeded_no0_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
hist(reseededclusters$per_reseeded_50r[which(reseededclusters$per_reseeded_50r > 0)], main = "50 Reefs (no 0s)", xlab = "Percent Re-seeded", col = "green", ylim = c(0,200))#
hist(reseededclusters$per_reseeded_pr[which(reseededclusters$per_reseeded_pr > 0)], main = "Predicted (no 0s)", xlab = "Percent Re-seeded",col = "brown", ylim = c(0,200))#
hist(reseededclusters$per_reseeded_cr[which(reseededclusters$per_reseeded_cr > 0)], main = "Catastrophe (no 0s)", xlab = "Percent Re-seeded", col = "pink", ylim = c(0,200))#
dev.off()#
#
png(paste0("Realized_CU_Full_PerReseeded_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
plot(x = reseededclusters$clustersize,y = reseededclusters$per_reseeded_50r, main = "50 Reefs", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "green", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_pr, x = reseededclusters$clustersize, main = "Predicted", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "brown", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_cr, x = reseededclusters$clustersize, main = "Catastrophe", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "pink", ylim = c(0,100), pch=20)#
dev.off()#
#
png(paste0("Realized_CU_Full_NumReseeded_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
plot(x = reseededclusters$clustersize,y = reseededclusters$num_reseeded_50r, main = "50 Reefs", ylab = "Number of Cells Re-seeded", xlab = "Cluster Size", col = "green", pch=20)#
plot(y = reseededclusters$num_reseeded_pr, x = reseededclusters$clustersize, main = "Predicted", ylab = "Number of Cells Re-seeded", xlab = "Cluster Size", col = "brown", pch=20)#
plot(y = reseededclusters$num_reseeded_cr, x = reseededclusters$clustersize, main = "Catastrophe", ylab = "Number of Cells Re-seeded", xlab = "Cluster Size", col = "pink", pch=20)#
dev.off()#
#
png(paste0("Realized_CU_Full_PerReseeded_no0_",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
plot(x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_50r > 0)],y = reseededclusters$per_reseeded_50r[which(reseededclusters$per_reseeded_50r > 0)], main = "50 Reefs (no 0s)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "green", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_pr[which(reseededclusters$per_reseeded_pr > 0)], x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_pr > 0)], main = "Predicted (no 0s)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "brown", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_cr[which(reseededclusters$per_reseeded_cr > 0)], x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_cr > 0)], main = "Catastrophe (no 0s)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "pink", ylim = c(0,100), pch=20)#
dev.off()#
#
png(paste0("Realized_CU_Full_PerReseeded_no0_nobigcluster",numsteps,"steps.png"))#
par(mfrow = c(1,3))#
plot(x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_50r > 0 & reseededclusters$clustersize < 1000)],y = reseededclusters$per_reseeded_50r[which(reseededclusters$per_reseeded_50r > 0 & reseededclusters$clustersize < 1000)], main = "50 Reefs (no 0s, no big cluster)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "green", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_pr[which(reseededclusters$per_reseeded_pr > 0 & reseededclusters$clustersize < 1000)], x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_pr > 0 & reseededclusters$clustersize < 1000)], main = "Predicted (no 0s, no big cluster)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "brown", ylim = c(0,100), pch=20)#
plot(y = reseededclusters$per_reseeded_cr[which(reseededclusters$per_reseeded_cr > 0 & reseededclusters$clustersize < 1000)], x = reseededclusters$clustersize[which(reseededclusters$per_reseeded_cr > 0 & reseededclusters$clustersize < 1000)], main = "Catastrophe (no 0s, no big cluster)", ylab = "Percent Re-seeded", xlab = "Cluster Size", col = "pink", ylim = c(0,100), pch=20)#
dev.off()#
#
#RESEEDING FROM RANDOM SCENARIO#
set.seed(2)#
abundmatlist <- starterreefslist <- numreseededrrlist <- id.totalnotseeded <- perreseededrr <- list()#
numsteps <- 50#
num_remove <- 434#
num_iter <- 20#
random_iter <- 100#
final_reef <- (num_iter*num_remove)#
plateaupoint <- 500#
plateaupoint_rr <- rep(NA,random_iter)#
reefdata$num <- seq(1,12292,by=1)#
for(j in 1:random_iter){#
ord <- sample(seq(1,length(reefdata$score),by=1))#
starterreefs <- reefdata$num[-ord[1:final_reef]]#
abundance_mat <- matrix(data = 0, nrow = dim(connmat_reduced)[1], ncol = (numsteps+1)) #50 time steps#
abundance_mat[,1][starterreefs] <- 100 #time step 0: assign all the starterreefs to an abundance of 100#
#
#calculate abundance after 1 time step#
abundance_mat[,2] <- as.vector(t(abundance_mat[,1]) %*% connmat_reduced) #need to do this because it thinks of the right side as a matrix#
#re-set abundance of all non-vacant reefs to 100#
dummy <- abundance_mat[,2]#
dummy[dummy > 0] <- 100 #
#calculate abundance for the next 9 time steps - note: the total abundance/sum of the subsequent columns should decrease every time step#
for(i in 3:(numsteps+1)){#
abundance_mat[,i] <- as.vector(t(dummy) %*% connmat_reduced)#
dummy <- abundance_mat[,i]#
dummy[dummy > 0] <- 100#
}#
#
abundmatlist[[j]] <- abundance_mat#
starterreefslist[[j]] <- starterreefs#
#Plot the number that were re-seeded over time#
stop <- "no"#
numreseeded_rr <- rep(NA,(numsteps+1))#
numreseeded_rr[1] <- 0#
for(i in 2:(numsteps+1)){#
numreseeded_rr[i] <- length(abundance_mat[,i][abundance_mat[,i]>0]) - length(abundance_mat[starterreefs,i][abundance_mat[starterreefs,i]>0])	#
if((numreseeded_rr[i] <= numreseeded_rr[i-1]) & stop == "no"){ #OR if more reseeded in the previous step (to deal with the flip-flopping)#
	plateaupoint <- i-1#
	stop <- "yes"#
	}#
}#
plateaupoint_rr[j] <- plateaupoint#
numreseededrrlist[[j]] <- numreseeded_rr#
#
id.totalnotseeded[[j]] <- which(abundance_mat[,(numsteps+1)] == 0)#
}#
#
meanplateauptrr <- mean(plateaupoint_rr)#
#
numreseededrr_mean <- rep(NA,(numsteps+1))#
numreseededrr_sd <- rep(NA,(numsteps+1))#
set <- rep(NA,random_iter)#
for(i in 1:(numsteps+1)){#
	for(j in 1:random_iter){#
	set[j] <- numreseededrrlist[[j]][i]#
	}#
	numreseededrr_mean[i] <- mean(set)#
	numreseededrr_sd[i] <- sd(set)#
	set <- rep(NA,random_iter)	#
}#
png(paste0("Realized_CU_Random_Reseed_",numsteps,"steps.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=numreseededrr_mean,main="Realized Random Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "# of Reseeded Reefs", type = "n")#
for(i in 1:random_iter){#
	lines(x = seq(1,(numsteps+1),by=1),y = numreseededrrlist[[i]],col = alpha("blue", 0.2))#
}#
points(x=seq(1,(numsteps+1),by=1),y=numreseededrr_mean, pch=20)#
dev.off()#
#
#NOT SURE IF THIS MAKES SENSE TO PLOT...NEED TO THINK ABOUT#
#Histogram of percentage of each of the initial clusters that have been rebuilt#
#load in original cluster designations#
#reefdata2 <- reefdata[,c(2,3,4)]#
#g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)#
#reefdata2$cl.m <- clusters(g_orig, mode = "weak")$membership#
#range(clusters(g_orig, mode = "weak")$membership)[2] #604 clusters#
#
#reefdata is in the same order as abundance_mat (see: use + construction of id.reefs)#
#so can add in another column to reefdata2 with abundance y/n re: re-seeding#
#reefdata2 <- reefdata[,c(2,3,4)]#
#
for(j in 1:random_iter){#
reefdata2$final_abund_rr <- 1#
reefdata2$final_abund_rr[id.totalnotseeded[[j]]] <- 0#
head(reefdata2$final_abund_rr)#
#
#reseededclusters <- data.frame(clusterID <- seq(1,clusters(g_orig, mode = "weak")$no,by=1), clustersize <- clusters(g_orig, mode = "weak")$csize, num_reseeded_50r <- NA, per_reseeded_50r <- NA,num_reseeded_pr <- NA, per_reseeded_pr <- NA,num_reseeded_cr <- NA, per_reseeded_cr <- NA)#
for(i in 1:(clusters(g_orig, mode = "weak")$no)){#
	reseededclusters$num_reseeded_rr[i] <- sum(reefdata2$final_abund_rr[reefdata2$cl.m == i])#
	reseededclusters$per_reseeded_rr[i] <- (reseededclusters$num_reseeded_rr[i]/reseededclusters$clustersize[i])*100#
}#
perreseededrr[[j]] <- reseededclusters$per_reseeded_rr#
}#
#
perreseededrr_mean <- rep(NA,(numsteps+1))#
perreseededrr_sd <- rep(NA,(numsteps+1))#
set <- rep(NA,random_iter)#
for(i in 1:(numsteps+1)){#
	for(j in 1:random_iter){#
	set[j] <- perreseededrr[[j]][i]#
	}#
	perreseededrr_mean[i] <- mean(set)#
	perreseededrr_sd[i] <- sd(set)#
	set <- rep(NA,random_iter)	#
}#
#
png(paste0("Realized_CU_MeanRandom_HistPerReseeded_",numsteps,"steps.png"))#
hist(perreseededrr_mean, main = "Mean Percentage of Each Original Cluster that was Re-seeded", xlab = "Percent Re-seeded")#
dev.off()#
#
abundance_mat <- NA#
plateaupoint <- 500#
#
#plotting all of the numreseeeded from the 4 different 'scenarios' on one graph#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=((numreseeded_50r/12292)*100),main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", col = "green", type = 'l', ylim = c(0,60))#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_pr/12292)*100), col = "brown")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_cr/12292)*100), col  = "pink")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseededrr_mean/12292)*100), col  = "red",lty =3)#
legend("bottomright", c("50 Reefs", "Predicted", "Catastrophe","Random"), col = c("green","brown","pink","red"), lty = c(1,1,1,3))#
dev.off()#
#
#plotting all of the numreseeeded from the 4 different 'scenarios' on one graph - PERCENTAGE OF RE-SEEDED NOT INCLUDING STARTER REEFS#
numpossiblereseeded50r <- 12292-length(id.50reefs)#
numpossiblereseeded <- 12292-(12292 - final_reef) #12292 - final_reef = number started with in the predicted and catastrophe situations#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios_fixedpercentages.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=((numreseeded_50r/numpossiblereseeded50r)*100),main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", col = "green", type = 'l', ylim = c(0,80))#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_pr/numpossiblereseeded)*100), col = "brown")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_cr/numpossiblereseeded)*100), col  = "pink")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseededrr_mean/numpossiblereseeded)*100), col  = "red",lty =3)#
legend("bottomright", c("50 Reefs", "Predicted", "Catastrophe","Random"), col = c("green","brown","pink","red"), lty = c(1,1,1,3))#
dev.off()#
#
#for appraisal#
#plotting all of the numreseeeded from the 4 different 'scenarios' on one graph - total seeded as a PERCENTTAGE OF TOTAL REEFS#
#12292 - final_reef = number started with in the predicted and catastrophe situations#
initialreefs = 12292 - final_reef#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios_totalpercentages.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_50r+length(id.50reefs))/12292)*100),main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", col = "green", type = 'l', ylim = c(20,100), lwd = 3)#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_pr + initialreefs)/12292)*100), col = "blue",lwd = 3)#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_cr + initialreefs)/12292)*100), col  = "orange", lwd = 3)#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseededrr_mean + initialreefs)/12292)*100), col  = "red",lty =3, lwd = 3)#
legend("bottomright", c("50 Reefs", "PCS Hyp", "Cautionary Hyp","Random Hyp"), col = c("green","blue","orange","red"), lty = c(1,1,1,3), lwd = c(3,3,3,3))#
dev.off()#
#
#no 50 reefs for GCC poster#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios_totalpercentages_no50r.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_pr + initialreefs)/12292)*100), col = "blue",lwd = 3,main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", type = 'l', ylim = c(20,100))#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseeded_cr + initialreefs)/12292)*100), col  = "orange", lwd = 3)#
lines(x=seq(1,(numsteps+1),by=1),y=(((numreseededrr_mean + initialreefs)/12292)*100), col  = "red",lty =3, lwd = 3)#
legend("bottomright", c("PCS Hyp", "Cautionary Hyp","Random Hyp"), col = c("blue","orange","red"), lty = c(1,1,3), lwd = c(3,3,3))#
dev.off()#
#
#not including the 50 reefs scenario#
#
png(paste0("Realized_CU_ReseedFull_",numsteps,"steps_allscenarios_fixedpercentages_no50r.png"))#
plot(x=seq(1,(numsteps+1),by=1),y=((numreseeded_pr/numpossiblereseeded)*100), col = "green",main="Realized Scenario Final Reefs Reseeded over Time",xlab = "Time Step", ylab = "%  of Reefs Reseeded", type = 'l', ylim = c(0,80))#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseeded_cr/numpossiblereseeded)*100), col  = "brown")#
lines(x=seq(1,(numsteps+1),by=1),y=((numreseededrr_mean/numpossiblereseeded)*100), col  = "red",lty =3)#
legend("bottomright", c("Predicted", "Catastrophe","Random"), col = c("green","brown","red"), lty = c(1,1,3))#
dev.off()
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(ggplot2)#
library(maps)#
#
plot.map<- function(database,center,...){#
    Obj <- map(database,...,plot=F)#
    coord <- cbind(Obj[[1]],Obj[[2]])#
#
    # split up the coordinates#
    id <- rle(!is.na(coord[,1]))#
    id <- matrix(c(1,cumsum(id$lengths)),ncol=2,byrow=T)#
    polygons <- apply(id,1,function(i){coord[i[1]:i[2],]})#
#
    # split up polygons that differ too much#
    polygons <- lapply(polygons,function(x){#
        x[,1] <- x[,1] + center#
        x[,1] <- ifelse(x[,1]>180,x[,1]-360,x[,1])#
        if(sum(diff(x[,1])>300,na.rm=T) >0){#
          id <- x[,1] < 0#
          x <- rbind(x[id,],c(NA,NA),x[!id,])#
       }#
       x#
    })#
    # reconstruct the object#
    polygons <- do.call(rbind,polygons)#
    Obj[[1]] <- polygons[,1]#
    Obj[[2]] <- polygons[,2]#
#
    map(Obj,...)#
}#
####3.3% Removal Scenario#####
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#thresholding by 3.3% probability (see 'Comparing_Options' file, note: connmat_reduced@x turns the matrix into a vector)#
connmat_reduced@x[connmat_reduced@x <= 0.033] <- 0#
#check - okay it's actually fine#
which(connmat_reduced[which(connmat_reduced <= 0.033)] > 0)#
#
#method 2#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
#
#load in the centroids, NOTE: NEED TO FIX THE LONGITUDE IN THESE ONES (>180 ones need to have -360 subtracted)#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/centroids.RData')#
#head(centroids) #
reefdata_full <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/RecalculatingResultswithNewScores_2.2020/scaled_scores_latlong_reproj_SJ.csv")#
head(reefdata_full)#
dim(reefdata_full)#
reefdata <- reefdata_full[,c(3:6,34,13:28)]#
head(reefdata)#
names(reefdata) <- c("TARGET_FID","PolyNo","Longitude", "Latitude", "score","reefpct","BCU_ID","BCU_Name","ReefArea","RfPctArea","BCUarea","BCUpctarea","Protectedarea","pct_Protectedarea","MarineRealm","MRealm_Name", "NumEEZ", "EEZName", "EEZ_Sovereign1","EEZ_Sovereign2","EEZ_Sovereign3")#
#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata_old <- b@data#
head(reefdata_old)#
#
#remove the rows corresponding to the grid cells that have no reef SA#
centroids_reduced <- centroids[-id.noReef,]#
#dim(centroids_reduced) #12292 #
#save(centroids_reduced, file = "centroids_reduced.RData")#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2#
#
#correct the longitude#
reefdata$Longitude[reefdata$Longitude > 180] <- reefdata$Longitude[reefdata$Longitude > 180] - 360#
centroids_reduced$Longitude[centroids_reduced$Longitude > 180] <- centroids_reduced$Longitude[centroids_reduced$Longitude > 180] - 360#
#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360
reefdata1 <- reefdata[,c(2,3,4,5,7,8,9,22)]
head(reefdata1)
?sample
length(reefdata1$PolyNo)
reefdata1$PolyNo[12292]
reefdata1$PolyNo
head(reefdata)
head(reefdata1)
library(readr)#
library(tidyverse)
?map_dbl
reefs.df <- read.csv(file = "~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/FixedData_1.20.2020/50Reefs_data/tabular/50Reefs_dataset.csv")
head(reefs.df)
dim(reefs.df)
reefs.df.stdized <- unname(reefs.df) #removes the column names
reefs.df.stdized <- as.matrix(reefs.df.stdized) #these two rows were to avoid the for loops below and be able to just use Row or Col sum but it didn't work for some reason
for(i in 5:178){
for(i in 5:178){#
	reefs.df.stdized[,i] <- (reefs.df.stdized[,i] - mean(reefs.df.stdized[,i]))/sd(reefs.df.stdized[,i]) #'mean 0 and unit variance standardization'#
	if(sd(reefs.df.stdized[,i]) == 0){#
		break;#
	}#
	reefs.df.stdized[,i] <- -reefs.df.stdized[,i] #'sign changed such that higher values are more desirable' #did it so higher values are bad and that didn't work either#
}
#order of scores: thermal stress history metrics (13, col 5:17), thermal stress projection metrics (8*19), recent thermal conditions (4), connectivity (2), cyclones (3)#
#names(reefs.df)[5:17] #thermal stress history metrics#
tsh_met <- as.matrix(reefs.df.stdized[,5:17])#
#names(reefs.df)[18:169] #thermal stress projection metrics#
tsp_met <- as.matrix(reefs.df.stdized[,18:169])#
#names(reefs.df)[170:173] #recent thermal conditions#
rtc_met <- as.matrix(reefs.df.stdized[,170:173])#
#names(reefs.df)[174:175] #connectivity#
conn_met <- as.matrix(-reefs.df.stdized[,174:175]) #because had the right sign to begin with, higher values = better for corals#
#names(reefs.df)[176:178] #cyclones#
cyc_met <- as.matrix(-reefs.df.stdized[,176:178]) #this one apparently flips too..
#1.28.2020 - calculating scores without connectivity data#
tshnum <- 13#
tspnum <- 8*19#
rtcnum <- 4#
#connnum <- 2#
cycnum <- 3#
#library(matrixStats)#
#tsh_num <- rowSums[tsh_met] <- this isn't working for some reason#
tsh_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsh_num[i] <- sum(tsh_met[i,])#
}#
tsp_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	tsp_num[i] <- sum(tsp_met[i,])#
}#
rtc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	rtc_num[i] <- sum(rtc_met[i,])#
}#
#conn_num <- c(NA,dim(reefs.df)[1])#
#for(i in 1:dim(reefs.df)[1]){#
#	conn_num[i] <- sum(conn_met[i,])#
#}#
cyc_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	cyc_num[i] <- sum(cyc_met[i,])#
}
connnum <- 2
conn_num <- c(NA,dim(reefs.df)[1])#
for(i in 1:dim(reefs.df)[1]){#
	conn_num[i] <- sum(conn_met[i,])#
}
score_tsh <- tsh_num/tshnum#
score_tsp <- tsp_num/tspnum#
score_rtc <- rtc_num/rtcnum#
score_cyc <- cyc_num/cycnum#
score_con <- conn_num/connum
connnum <- 2
score_con <- conn_num/connnum
fiftyreefsdata <- readOGR("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/DatafromMarco/reef_cells_allstat/reef_cells_allstat.shp")
library(rgdal)
fiftyreefsdata <- readOGR("~/Dropbox/University of Toronto/Research Related/Hawthorne Beyer Data/DatafromMarco/reef_cells_allstat/reef_cells_allstat.shp")
orig_data <- fiftyreefsdata@data
head(orig_data)
sum(scoreth - score_tsh)#
sum(scorepfc - score_tsp)#
sum(scoretr - score_rtc)#
sum(scorecn - score_con)#
sum(scorecy - score_cyc)
sum(orig_data$scoreth - score_tsh)#
sum(orig_data$scorepfc - score_tsp)#
sum(orig_data$scoretr - score_rtc)#
sum(orig_data$scorecn - score_con)#
sum(orig_data$scorecy - score_cyc)
sum(abs(orig_data$scoreth - score_tsh))#
sum(abs(orig_data$scorepfc - score_tsp))#
sum(abs(orig_data$scoretr - score_rtc))#
sum(abs(orig_data$scorecn - score_con))#
sum(abs(orig_data$scorecy - score_cyc))
library(sp)
library(rgdal)
data <- read.csv("~/GitHub/WCSFiji2020Internship/Fiji-status/Plot_Fiji/sites_to_provinces_YN_all.csv")
summary(data)
EPSG <- make_EPSG()
id <- which(EPSG$code == 4326)
WGS84_proj <- EPSG$prj4[id]
p <- SpatialPointsDataFrame(coords=data[,c("longitude","latitude")],#
                       data=data,#
                       proj4string = CRS(WGS84_proj))
id <- which(EPSG$code == 3832)#
new_proj <- EPSG$prj4[id]#
p_150 <- spTransform(p,CRS(new_proj))#
writeOGR(p_150,getwd(),"points_150",driver="ESRI Shapefile")#
# Others CRS that should be good for Fiji: https://epsg.io/?q=Fiji
countries <- readOGR(getwd(),"ne_10m_admin_0_countries")#
fiji <- countries[countries$NAME == "Fiji",]#
plot(fiji)#
proj4string(fiji)#
fiji_150 <- spTransform(fiji,CRS(new_proj))#
plot(fiji_150)#
writeOGR(fiji_150,getwd(),"fiji150",driver="ESRI Shapefile")
countries <- readOGR("~/GitHub/WCSFiji2020Internship/Fiji-status/Plot_Fiji/","~/GitHub/WCSFiji2020Internship/Fiji-status/Plot_Fiji/ne_10m_admin_0_countries")
countries <- readOGR("~/GitHub/WCSFiji2020Internship/Fiji-status/Plot_Fiji/","ne_10m_admin_0_countries")
fiji <- countries[countries$NAME == "Fiji",]#
plot(fiji)#
proj4string(fiji)#
fiji_150 <- spTransform(fiji,CRS(new_proj))#
plot(fiji_150)
library(tmaptools)
bb.fiji_150 <- bb(fiji_150, height = 0.5, relative = T, output="matrix")
library(tmap)
map <-
map <-#
    tm_shape(fiji_150,bbox=bb.fiji_150) +#
    tm_fill(col="gray") +#
    tm_shape(p_150) +#
    tm_dots(col="province")
map
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(maps)#
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#thresholding by 3.3% probability (see 'Comparing_Options' file, note: connmat_reduced@x turns the matrix into a vector)#
connmat_reduced@x[connmat_reduced@x <= 0.033] <- 0#
#check - okay it's actually fine#
which(connmat_reduced[which(connmat_reduced <= 0.033)] > 0)#
#
#method 2#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
connmat_reduced <- connmat_thresholder#
#check#
connmat_reduced[which(connmat_reduced <= 0.033)] #same weirdness (no actually it's fine)#
#
#load in the centroids, NOTE: NEED TO FIX THE LONGITUDE IN THESE ONES (>180 ones need to have -360 subtracted)#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/centroids.RData')#
#head(centroids) #
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata <- b@data#
#
#remove the rows corresponding to the grid cells that have no reef SA#
centroids_reduced <- centroids[-id.noReef,]#
dim(centroids_reduced) #12292 #
#save(centroids_reduced, file = "centroids_reduced.RData")#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2
world <- readOGR(dsn = "~/Dropbox/University of Toronto/Research Related/Code from Marco 6.2018 mediterranean larval connectivity/worldcountryshapeetc", layer = "ne_110m_admin_0_countries")#
#
plot.map<- function(database,center,...){#
    Obj <- map(database,...,plot=F)#
    coord <- cbind(Obj[[1]],Obj[[2]])#
#
    # split up the coordinates#
    id <- rle(!is.na(coord[,1]))#
    id <- matrix(c(1,cumsum(id$lengths)),ncol=2,byrow=T)#
    polygons <- apply(id,1,function(i){coord[i[1]:i[2],]})#
#
    # split up polygons that differ too much#
    polygons <- lapply(polygons,function(x){#
        x[,1] <- x[,1] + center#
        x[,1] <- ifelse(x[,1]>180,x[,1]-360,x[,1])#
        if(sum(diff(x[,1])>300,na.rm=T) >0){#
          id <- x[,1] < 0#
          x <- rbind(x[id,],c(NA,NA),x[!id,])#
       }#
       x#
    })#
    # reconstruct the object#
    polygons <- do.call(rbind,polygons)#
    Obj[[1]] <- polygons[,1]#
    Obj[[2]] <- polygons[,2]#
#
    map(Obj,...)#
}#
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360
clusters(g_orig, mode = "weak")$no
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)
clusters(g_orig, mode = "weak")$no
clusters(g_orig, mode = "weak")
library(rgdal)#
library(Matrix)#
library(igraph)#
library(fields)#
library(scales)#
library(maps)#
#load connectivity matrix#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/connmat_reduced.RData')#
dim(connmat_reduced) #12292x12292 with >0 reef SA#
#thresholding by 3.3% probability (see 'Comparing_Options' file, note: connmat_reduced@x turns the matrix into a vector)#
connmat_reduced@x[connmat_reduced@x <= 0.033] <- 0#
#check - okay it's actually fine#
which(connmat_reduced[which(connmat_reduced <= 0.033)] > 0)#
#
#method 2#
connmat_thresholder <- connmat_reduced#
#test <- matrix(c(1,3,2,4), nrow = 2, ncol = 2)#
#test[test <= 2] <- 0#
#     [,1] [,2]#
#[1,]    0    0#
#[2,]    3    4#
connmat_thresholder[connmat_thresholder <= 0.033] <- 0#
connmat_reduced <- connmat_thresholder#
#check
#load in the centroids, NOTE: NEED TO FIX THE LONGITUDE IN THESE ONES (>180 ones need to have -360 subtracted)#
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/centroids.RData')#
#head(centroids) #
load('~/Dropbox/University of Toronto/Research Related/Sally Wood Connectivity Matrix/Ariel_connectivity_SallyWood50reefEEZWDPA_fromMarco/cells12292.RData') #this includes 'id.noReef' and 'b' (shapefile)#
reefdata <- b@data#
#
#remove the rows corresponding to the grid cells that have no reef SA#
centroids_reduced <- centroids[-id.noReef,]#
dim(centroids_reduced) #12292 #
#save(centroids_reduced, file = "centroids_reduced.RData")#
#
#what is the distribution of the scores?#
#hist(reefdata$score) #centred on 0, -1 to 0.2
reefdata$Longitude_corrected <- reefdata$Longitude#
newcentre <- 180#
range(reefdata$Longitude_corrected)#
reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] <- reefdata$Longitude_corrected[reefdata$Longitude > 0 & reefdata$Longitude  <  180] - newcentre#
#
reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] <- reefdata$Longitude_corrected[reefdata$Longitude < 0 & reefdata$Longitude  >  -180] + newcentre#
#reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] <- reefdata$Longitude_corrected[reefdata$Longitude_corrected > 180] - 360#
#
g_orig <- graph.adjacency(as.matrix(connmat_reduced), weighted = TRUE)
clusters(g_orig, mode = "weak")
rep(c(1,2,3), each = 3)
allparam_data <- read.csv(file = "~/GitHub/Cole_CoralRestorationModelling/Coral-Restoration-Modeling/code/equilibria/full_combo_data.csv")
head(allparam_data)
library(scales)#
library(deSolve)#
library(tidyverse)#
library(readxl)
allparam_data <- read_excel(file = "~/GitHub/Cole_CoralRestorationModelling/Coral-Restoration-Modeling/code/equilibria/full_restoration_model_output.xlsx")
allparam_data <- read_excel("~/GitHub/Cole_CoralRestorationModelling/Coral-Restoration-Modeling/code/equilibria/full_restoration_model_output.xlsx")
head(allparam_data)
allparam_data <- read.csv("~/GitHub/Cole_CoralRestorationModelling/Coral-Restoration-Modeling/code/equilibria/full_restoration_model_output.csv")
head(allparam_data)
setwd('~/Documents/computecanada_randomremovalmorereps_june2020/iterators')#
iterator_redux <- c(16,17,18,37,38,39,46,47,48,67,68,69,145,146,147,151,152,153,160,161,162,187,188,189,196,197,198)#
for(i in 1:27){#
write.table(iterator[i], file=paste0("iterator_randomrep",i+69,".csv"),sep=",",row.names=FALSE,col.names=FALSE)#
}
setwd('~/Documents/computecanada_randomremovalmorereps_june2020/iterators')#
iterator_redux <- c(16,17,18,37,38,39,46,47,48,67,68,69,145,146,147,151,152,153,160,161,162,187,188,189,196,197,198)#
for(i in 1:27){#
write.table(iterator_redux[i], file=paste0("iterator_randomrep",i+69,".csv"),sep=",",row.names=FALSE,col.names=FALSE)#
}
